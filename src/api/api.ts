/* tslint:disable */
/* eslint-disable */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountAddressRestrictionTransactionBodyDTO
 */
export interface AccountAddressRestrictionTransactionBodyDTO {
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountAddressRestrictionTransactionBodyDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof AccountAddressRestrictionTransactionBodyDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof AccountAddressRestrictionTransactionBodyDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * Transaction to prevent incoming and outgoing transactions for a given a set of addresses.
 * @export
 * @interface AccountAddressRestrictionTransactionDTO
 */
export interface AccountAddressRestrictionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'deadline': string;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof AccountAddressRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof AccountDTO
     */
    'version': number;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AccountDTO
     */
    'address': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof AccountDTO
     */
    'addressHeight': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountDTO
     */
    'publicKey': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof AccountDTO
     */
    'publicKeyHeight': string;
    /**
     * 
     * @type {AccountTypeEnum}
     * @memberof AccountDTO
     */
    'accountType': AccountTypeEnum;
    /**
     * 
     * @type {SupplementalPublicKeysDTO}
     * @memberof AccountDTO
     */
    'supplementalPublicKeys': SupplementalPublicKeysDTO;
    /**
     * 
     * @type {Array<ActivityBucketDTO>}
     * @memberof AccountDTO
     */
    'activityBuckets': Array<ActivityBucketDTO>;
    /**
     * Mosaic units owned.
     * @type {Array<Mosaic>}
     * @memberof AccountDTO
     */
    'mosaics': Array<Mosaic>;
    /**
     * Probability of an account to harvest the next block.
     * @type {string}
     * @memberof AccountDTO
     */
    'importance': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof AccountDTO
     */
    'importanceHeight': string;
}
/**
 * 
 * @export
 * @interface AccountIds
 */
export interface AccountIds {
    /**
     * Array of public keys.
     * @type {Array<string>}
     * @memberof AccountIds
     */
    'publicKeys'?: Array<string>;
    /**
     * Array of addresses.
     * @type {Array<string>}
     * @memberof AccountIds
     */
    'addresses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AccountInfoDTO
 */
export interface AccountInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof AccountInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {AccountDTO}
     * @memberof AccountInfoDTO
     */
    'account': AccountDTO;
}
/**
 * 
 * @export
 * @interface AccountKeyLinkNetworkPropertiesDTO
 */
export interface AccountKeyLinkNetworkPropertiesDTO {
    /**
     * to trigger plugin load
     * @type {string}
     * @memberof AccountKeyLinkNetworkPropertiesDTO
     */
    'dummy'?: string;
}
/**
 * 
 * @export
 * @interface AccountKeyLinkTransactionBodyDTO
 */
export interface AccountKeyLinkTransactionBodyDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof AccountKeyLinkTransactionBodyDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof AccountKeyLinkTransactionBodyDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * Transaction to delegate the account importance score to a proxy account. Required for all accounts willing to activate delegated harvesting. 
 * @export
 * @interface AccountKeyLinkTransactionDTO
 */
export interface AccountKeyLinkTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'deadline': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof AccountKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * Type of account key: * 0 - Unset. * 1 - Linked account public key. * 2 - Node public key on which remote is allowed to harvest. * 4 - VRF public key. 
 * @export
 * @enum {string}
 */

export const AccountKeyTypeFlagsEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4
} as const;

export type AccountKeyTypeFlagsEnum = typeof AccountKeyTypeFlagsEnum[keyof typeof AccountKeyTypeFlagsEnum];


/**
 * 
 * @export
 * @interface AccountLinkPublicKeyDTO
 */
export interface AccountLinkPublicKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountLinkPublicKeyDTO
     */
    'publicKey': string;
}
/**
 * 
 * @export
 * @interface AccountLinkVotingKeyDTO
 */
export interface AccountLinkVotingKeyDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountLinkVotingKeyDTO
     */
    'publicKey': string;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof AccountLinkVotingKeyDTO
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof AccountLinkVotingKeyDTO
     */
    'endEpoch': number;
}
/**
 * 
 * @export
 * @interface AccountLinkVotingKeysDTO
 */
export interface AccountLinkVotingKeysDTO {
    /**
     * 
     * @type {Array<AccountLinkVotingKeyDTO>}
     * @memberof AccountLinkVotingKeysDTO
     */
    'publicKeys': Array<AccountLinkVotingKeyDTO>;
}
/**
 * 
 * @export
 * @interface AccountMetadataTransactionBodyDTO
 */
export interface AccountMetadataTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof AccountMetadataTransactionBodyDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof AccountMetadataTransactionBodyDTO
     */
    'scopedMetadataKey': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof AccountMetadataTransactionBodyDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountMetadataTransactionBodyDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof AccountMetadataTransactionBodyDTO
     */
    'value': string;
}
/**
 * Transaction to create or modify a multisig account.
 * @export
 * @interface AccountMetadataTransactionDTO
 */
export interface AccountMetadataTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountMetadataTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AccountMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AccountMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountMetadataTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof AccountMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof AccountMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface AccountMosaicRestrictionTransactionBodyDTO
 */
export interface AccountMosaicRestrictionTransactionBodyDTO {
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountMosaicRestrictionTransactionBodyDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof AccountMosaicRestrictionTransactionBodyDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof AccountMosaicRestrictionTransactionBodyDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * Transaction to prevent incoming transactions containing a given set of mosaics.
 * @export
 * @interface AccountMosaicRestrictionTransactionDTO
 */
export interface AccountMosaicRestrictionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'deadline': string;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof AccountMosaicRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface AccountNamesDTO
 */
export interface AccountNamesDTO {
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AccountNamesDTO
     */
    'address': string;
    /**
     * Account linked namespace names.
     * @type {Array<string>}
     * @memberof AccountNamesDTO
     */
    'names': Array<string>;
}
/**
 * 
 * @export
 * @interface AccountOperationRestrictionTransactionBodyDTO
 */
export interface AccountOperationRestrictionTransactionBodyDTO {
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountOperationRestrictionTransactionBodyDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof AccountOperationRestrictionTransactionBodyDTO
     */
    'restrictionAdditions': Array<TransactionTypeEnum>;
    /**
     * Account restriction deletions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof AccountOperationRestrictionTransactionBodyDTO
     */
    'restrictionDeletions': Array<TransactionTypeEnum>;
}
/**
 * Transaction to prevent outgoing transactions by transaction type.
 * @export
 * @interface AccountOperationRestrictionTransactionDTO
 */
export interface AccountOperationRestrictionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'deadline': string;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<TransactionTypeEnum>;
    /**
     * Account restriction deletions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof AccountOperationRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<TransactionTypeEnum>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountOrderByEnum = {
    Id: 'id',
    Balance: 'balance'
} as const;

export type AccountOrderByEnum = typeof AccountOrderByEnum[keyof typeof AccountOrderByEnum];


/**
 * 
 * @export
 * @interface AccountPage
 */
export interface AccountPage {
    /**
     * Array of accounts.
     * @type {Array<AccountInfoDTO>}
     * @memberof AccountPage
     */
    'data': Array<AccountInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof AccountPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface AccountRestrictionDTO
 */
export interface AccountRestrictionDTO {
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof AccountRestrictionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Address, mosaic id, or transaction type to restrict.
     * @type {Array<AccountRestrictionDTOValuesInner>}
     * @memberof AccountRestrictionDTO
     */
    'values': Array<AccountRestrictionDTOValuesInner>;
}
/**
 * 
 * @export
 * @interface AccountRestrictionDTOValuesInner
 */
export interface AccountRestrictionDTOValuesInner {
}
/**
 * Type of account restriction: * 0x0001 (1 decimal) - Allow only incoming transactions from a given address. * 0x0002 (2 decimal) - Allow only incoming transactions containing a given mosaic identifier. * 0x4001 (16385 decimal) - Allow only outgoing transactions to a given address. * 0x4004 (16388 decimal) - Allow only outgoing transactions with a given transaction type. * 0x8001 (32769 decimal) - Block incoming transactions from a given address. * 0x8002 (32770 decimal) - Block incoming transactions containing a given mosaic identifier. * 0xC001 (49153 decimal) - Block outgoing transactions to a given address. * 0xC004 (49156 decimal) - Block outgoing transactions with a given transaction type. 
 * @export
 * @enum {string}
 */

export const AccountRestrictionFlagsEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_16385: 16385,
    NUMBER_16388: 16388,
    NUMBER_32769: 32769,
    NUMBER_32770: 32770,
    NUMBER_49153: 49153,
    NUMBER_49156: 49156
} as const;

export type AccountRestrictionFlagsEnum = typeof AccountRestrictionFlagsEnum[keyof typeof AccountRestrictionFlagsEnum];


/**
 * 
 * @export
 * @interface AccountRestrictionNetworkPropertiesDTO
 */
export interface AccountRestrictionNetworkPropertiesDTO {
    /**
     * Maximum number of account restriction values.
     * @type {string}
     * @memberof AccountRestrictionNetworkPropertiesDTO
     */
    'maxAccountRestrictionValues'?: string;
}
/**
 * 
 * @export
 * @interface AccountRestrictionsDTO
 */
export interface AccountRestrictionsDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof AccountRestrictionsDTO
     */
    'version': number;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AccountRestrictionsDTO
     */
    'address': string;
    /**
     * 
     * @type {Array<AccountRestrictionDTO>}
     * @memberof AccountRestrictionsDTO
     */
    'restrictions': Array<AccountRestrictionDTO>;
}
/**
 * 
 * @export
 * @interface AccountRestrictionsInfoDTO
 */
export interface AccountRestrictionsInfoDTO {
    /**
     * 
     * @type {AccountRestrictionsDTO}
     * @memberof AccountRestrictionsInfoDTO
     */
    'accountRestrictions': AccountRestrictionsDTO;
}
/**
 * 
 * @export
 * @interface AccountRestrictionsPage
 */
export interface AccountRestrictionsPage {
    /**
     * Array of account restrictions.
     * @type {Array<AccountRestrictionsInfoDTO>}
     * @memberof AccountRestrictionsPage
     */
    'data': Array<AccountRestrictionsInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof AccountRestrictionsPage
     */
    'pagination': Pagination;
}
/**
 * * 0 - Unlinked. * 1 - Balance-holding account that is linked to a remote harvester account. * 2 - Remote harvester account that is linked to a balance-holding account. * 3 - Remote harvester eligible account that is unlinked. 
 * @export
 * @enum {string}
 */

export const AccountTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];


/**
 * 
 * @export
 * @interface AccountsNamesDTO
 */
export interface AccountsNamesDTO {
    /**
     * Array of account names.
     * @type {Array<AccountNamesDTO>}
     * @memberof AccountsNamesDTO
     */
    'accountNames': Array<AccountNamesDTO>;
}
/**
 * Supplementary data stored for importance recalculation. At each importance recalculation, existing buckets are shifted, the working bucket is finalized and a new working bucket is created. Each bucket influences at most five importance recalculations. 
 * @export
 * @interface ActivityBucketDTO
 */
export interface ActivityBucketDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof ActivityBucketDTO
     */
    'startHeight': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof ActivityBucketDTO
     */
    'totalFeesPaid': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof ActivityBucketDTO
     */
    'beneficiaryCount': number;
    /**
     * Probability of an account to harvest the next block.
     * @type {string}
     * @memberof ActivityBucketDTO
     */
    'rawScore': string;
}
/**
 * 
 * @export
 * @interface AddressAliasTransactionBodyDTO
 */
export interface AddressAliasTransactionBodyDTO {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof AddressAliasTransactionBodyDTO
     */
    'namespaceId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AddressAliasTransactionBodyDTO
     */
    'address': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof AddressAliasTransactionBodyDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * Transaction to link a namespace to an account.
 * @export
 * @interface AddressAliasTransactionDTO
 */
export interface AddressAliasTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AddressAliasTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AddressAliasTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AddressAliasTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AddressAliasTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'deadline': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'namespaceId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AddressAliasTransactionDTO
     */
    'address': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof AddressAliasTransactionDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * 
 * @export
 * @interface Addresses
 */
export interface Addresses {
    /**
     * Array of addresses.
     * @type {Array<string>}
     * @memberof Addresses
     */
    'addresses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AggregateNetworkPropertiesDTO
 */
export interface AggregateNetworkPropertiesDTO {
    /**
     * Maximum number of transactions per aggregate.
     * @type {string}
     * @memberof AggregateNetworkPropertiesDTO
     */
    'maxTransactionsPerAggregate'?: string;
    /**
     * Maximum number of cosignatures per aggregate.
     * @type {string}
     * @memberof AggregateNetworkPropertiesDTO
     */
    'maxCosignaturesPerAggregate'?: string;
    /**
     * Set to true if cosignatures must exactly match component signers. Set to false if cosignatures should be validated externally.
     * @type {boolean}
     * @memberof AggregateNetworkPropertiesDTO
     */
    'enableStrictCosignatureCheck'?: boolean;
    /**
     * Set to true if bonded aggregates should be allowed. Set to false if bonded aggregates should be rejected.
     * @type {boolean}
     * @memberof AggregateNetworkPropertiesDTO
     */
    'enableBondedAggregateSupport'?: boolean;
    /**
     * Maximum lifetime a bonded transaction can have before it expires.
     * @type {string}
     * @memberof AggregateNetworkPropertiesDTO
     */
    'maxBondedTransactionLifetime'?: string;
}
/**
 * 
 * @export
 * @interface AggregateTransactionBodyDTO
 */
export interface AggregateTransactionBodyDTO {
    /**
     * 
     * @type {string}
     * @memberof AggregateTransactionBodyDTO
     */
    'transactionsHash': string;
    /**
     * Array of transaction cosignatures.
     * @type {Array<CosignatureDTO>}
     * @memberof AggregateTransactionBodyDTO
     */
    'cosignatures': Array<CosignatureDTO>;
}
/**
 * 
 * @export
 * @interface AggregateTransactionBodyExtendedDTO
 */
export interface AggregateTransactionBodyExtendedDTO {
    /**
     * 
     * @type {string}
     * @memberof AggregateTransactionBodyExtendedDTO
     */
    'transactionsHash': string;
    /**
     * Array of transaction cosignatures.
     * @type {Array<CosignatureDTO>}
     * @memberof AggregateTransactionBodyExtendedDTO
     */
    'cosignatures': Array<CosignatureDTO>;
    /**
     * Array of transactions initiated by different accounts.
     * @type {Array<EmbeddedTransactionInfoDTO>}
     * @memberof AggregateTransactionBodyExtendedDTO
     */
    'transactions': Array<EmbeddedTransactionInfoDTO>;
}
/**
 * Transaction to combine multiple transactions together.
 * @export
 * @interface AggregateTransactionDTO
 */
export interface AggregateTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AggregateTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AggregateTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AggregateTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AggregateTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AggregateTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AggregateTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AggregateTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AggregateTransactionDTO
     */
    'deadline': string;
    /**
     * 
     * @type {string}
     * @memberof AggregateTransactionDTO
     */
    'transactionsHash': string;
    /**
     * Array of transaction cosignatures.
     * @type {Array<CosignatureDTO>}
     * @memberof AggregateTransactionDTO
     */
    'cosignatures': Array<CosignatureDTO>;
}
/**
 * Transaction to combine multiple transactions together.
 * @export
 * @interface AggregateTransactionExtendedDTO
 */
export interface AggregateTransactionExtendedDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof AggregateTransactionExtendedDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof AggregateTransactionExtendedDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof AggregateTransactionExtendedDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof AggregateTransactionExtendedDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof AggregateTransactionExtendedDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AggregateTransactionExtendedDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof AggregateTransactionExtendedDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof AggregateTransactionExtendedDTO
     */
    'deadline': string;
    /**
     * 
     * @type {string}
     * @memberof AggregateTransactionExtendedDTO
     */
    'transactionsHash': string;
    /**
     * Array of transaction cosignatures.
     * @type {Array<CosignatureDTO>}
     * @memberof AggregateTransactionExtendedDTO
     */
    'cosignatures': Array<CosignatureDTO>;
    /**
     * Array of transactions initiated by different accounts.
     * @type {Array<EmbeddedTransactionInfoDTO>}
     * @memberof AggregateTransactionExtendedDTO
     */
    'transactions': Array<EmbeddedTransactionInfoDTO>;
}
/**
 * Alias action: * 0 - Unlink alias. * 1 - Link alias. 
 * @export
 * @enum {string}
 */

export const AliasActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type AliasActionEnum = typeof AliasActionEnum[keyof typeof AliasActionEnum];


/**
 * 
 * @export
 * @interface AliasDTO
 */
export interface AliasDTO {
    /**
     * 
     * @type {AliasTypeEnum}
     * @memberof AliasDTO
     */
    'type': AliasTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof AliasDTO
     */
    'mosaicId'?: string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof AliasDTO
     */
    'address'?: string;
}
/**
 * Type of alias: * 0 - No alias. * 1 - Mosaic id alias. * 2 - Addres alias. 
 * @export
 * @enum {string}
 */

export const AliasTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type AliasTypeEnum = typeof AliasTypeEnum[keyof typeof AliasTypeEnum];


/**
 * 
 * @export
 * @interface AnnounceTransactionInfoDTO
 */
export interface AnnounceTransactionInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof AnnounceTransactionInfoDTO
     */
    'message': string;
}
/**
 * Receipt stored when a state change modified an account balance.
 * @export
 * @interface BalanceChangeReceiptDTO
 */
export interface BalanceChangeReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof BalanceChangeReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof BalanceChangeReceiptDTO
     */
    'type': ReceiptTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof BalanceChangeReceiptDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BalanceChangeReceiptDTO
     */
    'amount': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceChangeReceiptDTO
     */
    'targetAddress': string;
}
/**
 * 
 * @export
 * @interface BalanceChangeReceiptDTOAllOf
 */
export interface BalanceChangeReceiptDTOAllOf {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof BalanceChangeReceiptDTOAllOf
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BalanceChangeReceiptDTOAllOf
     */
    'amount': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceChangeReceiptDTOAllOf
     */
    'targetAddress': string;
}
/**
 * Receipt stored when a state change that triggered a mosaic transfer.
 * @export
 * @interface BalanceTransferReceiptDTO
 */
export interface BalanceTransferReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof BalanceTransferReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof BalanceTransferReceiptDTO
     */
    'type': ReceiptTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof BalanceTransferReceiptDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BalanceTransferReceiptDTO
     */
    'amount': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceTransferReceiptDTO
     */
    'senderAddress': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceTransferReceiptDTO
     */
    'recipientAddress': string;
}
/**
 * 
 * @export
 * @interface BalanceTransferReceiptDTOAllOf
 */
export interface BalanceTransferReceiptDTOAllOf {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof BalanceTransferReceiptDTOAllOf
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BalanceTransferReceiptDTOAllOf
     */
    'amount': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceTransferReceiptDTOAllOf
     */
    'senderAddress': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BalanceTransferReceiptDTOAllOf
     */
    'recipientAddress': string;
}
/**
 * 
 * @export
 * @interface BlockDTO
 */
export interface BlockDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof BlockDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof BlockDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof BlockDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof BlockDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof BlockDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BlockDTO
     */
    'type': number;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof BlockDTO
     */
    'height': string;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof BlockDTO
     */
    'timestamp': string;
    /**
     * Determines how hard is to harvest a new block, based on previous blocks.
     * @type {string}
     * @memberof BlockDTO
     */
    'difficulty': string;
    /**
     * 32-bytes VRF proof gamma.
     * @type {string}
     * @memberof BlockDTO
     */
    'proofGamma': string;
    /**
     * 16-bytes VRF proof verification hash.
     * @type {string}
     * @memberof BlockDTO
     */
    'proofVerificationHash': string;
    /**
     * 32-bytes VRF proof scalar.
     * @type {string}
     * @memberof BlockDTO
     */
    'proofScalar': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTO
     */
    'previousBlockHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTO
     */
    'transactionsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTO
     */
    'receiptsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTO
     */
    'stateHash': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BlockDTO
     */
    'beneficiaryAddress': string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof BlockDTO
     */
    'feeMultiplier': number;
}
/**
 * 
 * @export
 * @interface BlockDTOAllOf
 */
export interface BlockDTOAllOf {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'height': string;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'timestamp': string;
    /**
     * Determines how hard is to harvest a new block, based on previous blocks.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'difficulty': string;
    /**
     * 32-bytes VRF proof gamma.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'proofGamma': string;
    /**
     * 16-bytes VRF proof verification hash.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'proofVerificationHash': string;
    /**
     * 32-bytes VRF proof scalar.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'proofScalar': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'previousBlockHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'transactionsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'receiptsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'stateHash': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BlockDTOAllOf
     */
    'beneficiaryAddress': string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof BlockDTOAllOf
     */
    'feeMultiplier': number;
}
/**
 * 
 * @export
 * @interface BlockInfoDTO
 */
export interface BlockInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof BlockInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {BlockMetaDTO}
     * @memberof BlockInfoDTO
     */
    'meta': BlockMetaDTO;
    /**
     * 
     * @type {BlockInfoDTOBlock}
     * @memberof BlockInfoDTO
     */
    'block': BlockInfoDTOBlock;
}
/**
 * 
 * @export
 * @interface BlockInfoDTOBlock
 */
export interface BlockInfoDTOBlock {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof BlockInfoDTOBlock
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof BlockInfoDTOBlock
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof BlockInfoDTOBlock
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof BlockInfoDTOBlock
     */
    'type': number;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'height': string;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'timestamp': string;
    /**
     * Determines how hard is to harvest a new block, based on previous blocks.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'difficulty': string;
    /**
     * 32-bytes VRF proof gamma.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'proofGamma': string;
    /**
     * 16-bytes VRF proof verification hash.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'proofVerificationHash': string;
    /**
     * 32-bytes VRF proof scalar.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'proofScalar': string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'previousBlockHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'transactionsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'receiptsHash': string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'stateHash': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'beneficiaryAddress': string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof BlockInfoDTOBlock
     */
    'feeMultiplier': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof BlockInfoDTOBlock
     */
    'votingEligibleAccountsCount': number;
    /**
     * A number that allows uint 64 values represented with a string.
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'harvestingEligibleAccountsCount': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'totalVotingBalance': string;
    /**
     * 
     * @type {string}
     * @memberof BlockInfoDTOBlock
     */
    'previousImportanceBlockHash': string;
}
/**
 * 
 * @export
 * @interface BlockMetaDTO
 */
export interface BlockMetaDTO {
    /**
     * 
     * @type {string}
     * @memberof BlockMetaDTO
     */
    'hash': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof BlockMetaDTO
     */
    'totalFee': string;
    /**
     * 
     * @type {string}
     * @memberof BlockMetaDTO
     */
    'generationHash': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlockMetaDTO
     */
    'stateHashSubCacheMerkleRoots': Array<string>;
    /**
     * Total number of [transactions](https://docs.symbolplatform.com/concepts/transaction.html) confirmed in this block, including *embedded* transactions (i.e. transactions contained within aggregate transactions). 
     * @type {number}
     * @memberof BlockMetaDTO
     */
    'totalTransactionsCount': number;
    /**
     * Number of [transactions](https://docs.symbolplatform.com/concepts/transaction.html) confirmed in this block. This does not count *embedded* transactions (i.e. transactions contained within aggregate transactions). 
     * @type {number}
     * @memberof BlockMetaDTO
     */
    'transactionsCount': number;
    /**
     * Number of statements (of any kind) present in this block. Bear in mind that some of them (like [resolution statements](https://docs.symbolplatform.com/concepts/receipt.html#resolution-statement)) are triggered by transactions present in the block, but in general, [transaction statements](https://docs.symbolplatform.com/concepts/receipt.html#transaction-statement) are not. 
     * @type {number}
     * @memberof BlockMetaDTO
     */
    'statementsCount': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BlockOrderByEnum = {
    Id: 'id',
    Height: 'height'
} as const;

export type BlockOrderByEnum = typeof BlockOrderByEnum[keyof typeof BlockOrderByEnum];


/**
 * 
 * @export
 * @interface BlockPage
 */
export interface BlockPage {
    /**
     * Array of blocks.
     * @type {Array<BlockInfoDTO>}
     * @memberof BlockPage
     */
    'data': Array<BlockInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof BlockPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface BmTreeSignature
 */
export interface BmTreeSignature {
    /**
     * 
     * @type {ParentPublicKeySignaturePair}
     * @memberof BmTreeSignature
     */
    'root': ParentPublicKeySignaturePair;
    /**
     * 
     * @type {ParentPublicKeySignaturePair}
     * @memberof BmTreeSignature
     */
    'bottom': ParentPublicKeySignaturePair;
}
/**
 * 
 * @export
 * @interface ChainInfoDTO
 */
export interface ChainInfoDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof ChainInfoDTO
     */
    'height': string;
    /**
     * Score of the blockchain. During synchronization, nodes try to get the blockchain with highest score in the network. 
     * @type {string}
     * @memberof ChainInfoDTO
     */
    'scoreHigh': string;
    /**
     * Score of the blockchain. During synchronization, nodes try to get the blockchain with highest score in the network. 
     * @type {string}
     * @memberof ChainInfoDTO
     */
    'scoreLow': string;
    /**
     * 
     * @type {FinalizedBlockDTO}
     * @memberof ChainInfoDTO
     */
    'latestFinalizedBlock': FinalizedBlockDTO;
}
/**
 * Chain related configuration properties.
 * @export
 * @interface ChainPropertiesDTO
 */
export interface ChainPropertiesDTO {
    /**
     * Set to true if block chain should calculate state hashes so that state is fully verifiable at each block.
     * @type {boolean}
     * @memberof ChainPropertiesDTO
     */
    'enableVerifiableState'?: boolean;
    /**
     * Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block.
     * @type {boolean}
     * @memberof ChainPropertiesDTO
     */
    'enableVerifiableReceipts'?: boolean;
    /**
     * Mosaic id used as primary chain currency.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'currencyMosaicId'?: string;
    /**
     * Mosaic id used to provide harvesting ability.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'harvestingMosaicId'?: string;
    /**
     * Targeted time between blocks.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'blockGenerationTargetTime'?: string;
    /**
     * A higher value makes the network more biased.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'blockTimeSmoothingFactor'?: string;
    /**
     * Number of blocks between successive finalization attempts.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'blockFinalizationInterval'?: string;
    /**
     * Number of blocks that should be treated as a group for importance purposes.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'importanceGrouping'?: string;
    /**
     * Percentage of importance resulting from fee generation and beneficiary usage.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'importanceActivityPercentage'?: string;
    /**
     * Maximum number of blocks that can be rolled back.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxRollbackBlocks'?: string;
    /**
     * Maximum number of blocks to use in a difficulty calculation.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxDifficultyBlocks'?: string;
    /**
     * Default multiplier to use for dynamic fees.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'defaultDynamicFeeMultiplier'?: string;
    /**
     * Maximum lifetime a transaction can have before it expires.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxTransactionLifetime'?: string;
    /**
     * Maximum future time of a block that can be accepted.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxBlockFutureTime'?: string;
    /**
     * Initial currency atomic units available in the network.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'initialCurrencyAtomicUnits'?: string;
    /**
     * Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxMosaicAtomicUnits'?: string;
    /**
     * Total whole importance units available in the network.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'totalChainImportance'?: string;
    /**
     * Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'minHarvesterBalance'?: string;
    /**
     * Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxHarvesterBalance'?: string;
    /**
     * Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'minVoterBalance'?: string;
    /**
     * Maximum number of voting keys that can be registered at once per account.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxVotingKeysPerAccount'?: string;
    /**
     * Minimum number of finalization rounds for which voting key can be registered.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'minVotingKeyLifetime'?: string;
    /**
     * Maximum number of finalization rounds for which voting key can be registered.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxVotingKeyLifetime'?: string;
    /**
     * Percentage of the harvested fee that is collected by the beneficiary account.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'harvestBeneficiaryPercentage'?: string;
    /**
     * Percentage of the harvested fee that is collected by the network.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'harvestNetworkPercentage'?: string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'harvestNetworkFeeSinkAddress'?: string;
    /**
     * Number of blocks between cache pruning.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'blockPruneInterval'?: string;
    /**
     * Maximum number of transactions per block.
     * @type {string}
     * @memberof ChainPropertiesDTO
     */
    'maxTransactionsPerBlock'?: string;
}
/**
 * 
 * @export
 * @interface CommunicationTimestampsDTO
 */
export interface CommunicationTimestampsDTO {
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof CommunicationTimestampsDTO
     */
    'sendTimestamp'?: string;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof CommunicationTimestampsDTO
     */
    'receiveTimestamp'?: string;
}
/**
 * 
 * @export
 * @interface Cosignature
 */
export interface Cosignature {
    /**
     * 
     * @type {string}
     * @memberof Cosignature
     */
    'parentHash'?: string;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof Cosignature
     */
    'signature'?: string;
    /**
     * Public key.
     * @type {string}
     * @memberof Cosignature
     */
    'signerPublicKey'?: string;
    /**
     * Cosignature version.
     * @type {string}
     * @memberof Cosignature
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface CosignatureDTO
 */
export interface CosignatureDTO {
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof CosignatureDTO
     */
    'signature': string;
    /**
     * Cosignature version.
     * @type {string}
     * @memberof CosignatureDTO
     */
    'version': string;
    /**
     * Public key.
     * @type {string}
     * @memberof CosignatureDTO
     */
    'signerPublicKey': string;
}
/**
 * 
 * @export
 * @interface CosignatureDTOAllOf
 */
export interface CosignatureDTOAllOf {
    /**
     * Cosignature version.
     * @type {string}
     * @memberof CosignatureDTOAllOf
     */
    'version': string;
    /**
     * Public key.
     * @type {string}
     * @memberof CosignatureDTOAllOf
     */
    'signerPublicKey': string;
}
/**
 * 
 * @export
 * @interface DeploymentDTO
 */
export interface DeploymentDTO {
    /**
     * The tool used to create, maintain and deploy the node. Examples: symbol-bootstrap, manual.
     * @type {string}
     * @memberof DeploymentDTO
     */
    'deploymentTool': string;
    /**
     * The version of the tool used to create, maintain and deploy the node.
     * @type {string}
     * @memberof DeploymentDTO
     */
    'deploymentToolVersion': string;
    /**
     * When was the node last upgraded.
     * @type {string}
     * @memberof DeploymentDTO
     */
    'lastUpdatedDate': string;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountAddressRestrictionTransactionDTO
 */
export interface EmbeddedAccountAddressRestrictionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'type': number;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof EmbeddedAccountAddressRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountKeyLinkTransactionDTO
 */
export interface EmbeddedAccountKeyLinkTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof EmbeddedAccountKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountMetadataTransactionDTO
 */
export interface EmbeddedAccountMetadataTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof EmbeddedAccountMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountMosaicRestrictionTransactionDTO
 */
export interface EmbeddedAccountMosaicRestrictionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'type': number;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<string>}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<string>;
    /**
     * Account restriction deletions.
     * @type {Array<string>}
     * @memberof EmbeddedAccountMosaicRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface EmbeddedAccountOperationRestrictionTransactionDTO
 */
export interface EmbeddedAccountOperationRestrictionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'type': number;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'restrictionAdditions': Array<TransactionTypeEnum>;
    /**
     * Account restriction deletions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof EmbeddedAccountOperationRestrictionTransactionDTO
     */
    'restrictionDeletions': Array<TransactionTypeEnum>;
}
/**
 * 
 * @export
 * @interface EmbeddedAddressAliasTransactionDTO
 */
export interface EmbeddedAddressAliasTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'type': number;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'namespaceId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'address': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof EmbeddedAddressAliasTransactionDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedHashLockTransactionDTO
 */
export interface EmbeddedHashLockTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'type': number;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedHashLockTransactionDTO
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicAddressRestrictionTransactionDTO
 */
export interface EmbeddedMosaicAddressRestrictionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'mosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'newRestrictionValue': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedMosaicAddressRestrictionTransactionDTO
     */
    'targetAddress': string;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicAliasTransactionDTO
 */
export interface EmbeddedMosaicAliasTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'type': number;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'namespaceId': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'mosaicId': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof EmbeddedMosaicAliasTransactionDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicDefinitionTransactionDTO
 */
export interface EmbeddedMosaicDefinitionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'type': number;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'id': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'duration': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'nonce': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof EmbeddedMosaicDefinitionTransactionDTO
     */
    'divisibility': number;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicGlobalRestrictionTransactionDTO
 */
export interface EmbeddedMosaicGlobalRestrictionTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'mosaicId': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'referenceMosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'newRestrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'previousRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof EmbeddedMosaicGlobalRestrictionTransactionDTO
     */
    'newRestrictionType': MosaicRestrictionTypeEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicMetadataTransactionDTO
 */
export interface EmbeddedMosaicMetadataTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'targetMosaicId': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof EmbeddedMosaicMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicSupplyChangeTransactionDTO
 */
export interface EmbeddedMosaicSupplyChangeTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'type': number;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'delta': string;
    /**
     * 
     * @type {MosaicSupplyChangeActionEnum}
     * @memberof EmbeddedMosaicSupplyChangeTransactionDTO
     */
    'action': MosaicSupplyChangeActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedMosaicSupplyRevocationTransactionDTO
 */
export interface EmbeddedMosaicSupplyRevocationTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'sourceAddress': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedMosaicSupplyRevocationTransactionDTO
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface EmbeddedMultisigAccountModificationTransactionDTO
 */
export interface EmbeddedMultisigAccountModificationTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'type': number;
    /**
     * Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'minRemovalDelta': number;
    /**
     * Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'minApprovalDelta': number;
    /**
     * Array of cosignatory accounts to add.
     * @type {Array<string>}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'addressAdditions': Array<string>;
    /**
     * Array of cosignatory accounts to delete.
     * @type {Array<string>}
     * @memberof EmbeddedMultisigAccountModificationTransactionDTO
     */
    'addressDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface EmbeddedNamespaceMetadataTransactionDTO
 */
export interface EmbeddedNamespaceMetadataTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'targetNamespaceId'?: string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof EmbeddedNamespaceMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface EmbeddedNamespaceRegistrationTransactionDTO
 */
export interface EmbeddedNamespaceRegistrationTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'type': number;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'duration'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'parentId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'id': string;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Namespace name.
     * @type {string}
     * @memberof EmbeddedNamespaceRegistrationTransactionDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EmbeddedNodeKeyLinkTransactionDTO
 */
export interface EmbeddedNodeKeyLinkTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof EmbeddedNodeKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedSecretLockTransactionDTO
 */
export interface EmbeddedSecretLockTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'secret': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'duration': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof EmbeddedSecretLockTransactionDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedSecretProofTransactionDTO
 */
export interface EmbeddedSecretProofTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'secret': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Original random set of bytes.
     * @type {string}
     * @memberof EmbeddedSecretProofTransactionDTO
     */
    'proof': string;
}
/**
 * 
 * @export
 * @interface EmbeddedTransactionBodyDTO
 */
export interface EmbeddedTransactionBodyDTO {
    /**
     * Array of transactions initiated by different accounts.
     * @type {Array<EmbeddedTransactionInfoDTO>}
     * @memberof EmbeddedTransactionBodyDTO
     */
    'transactions': Array<EmbeddedTransactionInfoDTO>;
}
/**
 * 
 * @export
 * @interface EmbeddedTransactionDTO
 */
export interface EmbeddedTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedTransactionDTO
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface EmbeddedTransactionInfoDTO
 */
export interface EmbeddedTransactionInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {EmbeddedTransactionMetaDTO}
     * @memberof EmbeddedTransactionInfoDTO
     */
    'meta': EmbeddedTransactionMetaDTO;
    /**
     * 
     * @type {EmbeddedTransactionInfoDTOTransaction}
     * @memberof EmbeddedTransactionInfoDTO
     */
    'transaction': EmbeddedTransactionInfoDTOTransaction;
}
/**
 * 
 * @export
 * @interface EmbeddedTransactionInfoDTOTransaction
 */
export interface EmbeddedTransactionInfoDTOTransaction {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'type': number;
    /**
     * 32 bytes voting public key.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'linkAction': LinkActionEnum;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'endEpoch': number;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'hash': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'secret': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Original random set of bytes.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'proof': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'scopedMetadataKey': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'value': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'targetMosaicId': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'targetNamespaceId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'id': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'nonce': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'divisibility': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'delta': string;
    /**
     * 
     * @type {MosaicSupplyChangeActionEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'action': MosaicSupplyChangeActionEnum;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'sourceAddress': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'parentId'?: string;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Namespace name.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'name': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'namespaceId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'address': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'aliasAction': AliasActionEnum;
    /**
     * Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'minRemovalDelta': number;
    /**
     * Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'minApprovalDelta': number;
    /**
     * Array of cosignatory accounts to add.
     * @type {Array<string>}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'addressAdditions': Array<string>;
    /**
     * Array of cosignatory accounts to delete.
     * @type {Array<string>}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'addressDeletions': Array<string>;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'restrictionAdditions': Array<TransactionTypeEnum>;
    /**
     * Account restriction deletions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'restrictionDeletions': Array<TransactionTypeEnum>;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'referenceMosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'newRestrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'previousRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'newRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * Array of mosaics sent to the recipient. 
     * @type {Array<UnresolvedMosaic>}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'mosaics': Array<UnresolvedMosaic>;
    /**
     * Transfer transaction message
     * @type {string}
     * @memberof EmbeddedTransactionInfoDTOTransaction
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedTransactionMetaDTO
 */
export interface EmbeddedTransactionMetaDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'height': string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'aggregateHash': string;
    /**
     * Identifier of the aggregate transaction.
     * @type {string}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'aggregateId': string;
    /**
     * Transaction index within the aggregate.
     * @type {number}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'index': number;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'timestamp'?: string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof EmbeddedTransactionMetaDTO
     */
    'feeMultiplier'?: number;
}
/**
 * 
 * @export
 * @interface EmbeddedTransferTransactionDTO
 */
export interface EmbeddedTransferTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'type': number;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'recipientAddress': string;
    /**
     * Array of mosaics sent to the recipient. 
     * @type {Array<UnresolvedMosaic>}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'mosaics': Array<UnresolvedMosaic>;
    /**
     * Transfer transaction message
     * @type {string}
     * @memberof EmbeddedTransferTransactionDTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface EmbeddedVotingKeyLinkTransactionDTO
 */
export interface EmbeddedVotingKeyLinkTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * 32 bytes voting public key.
     * @type {string}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'endEpoch': number;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof EmbeddedVotingKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @interface EmbeddedVrfKeyLinkTransactionDTO
 */
export interface EmbeddedVrfKeyLinkTransactionDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Public key.
     * @type {string}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof EmbeddedVrfKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @interface EntityDTO
 */
export interface EntityDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof EntityDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof EntityDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof EntityDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof EntityDTO
     */
    'type': number;
}
/**
 * 
 * @export
 * @interface FinalizationProofDTO
 */
export interface FinalizationProofDTO {
    /**
     * 
     * @type {number}
     * @memberof FinalizationProofDTO
     */
    'version': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof FinalizationProofDTO
     */
    'finalizationEpoch': number;
    /**
     * Finalization point
     * @type {number}
     * @memberof FinalizationProofDTO
     */
    'finalizationPoint': number;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof FinalizationProofDTO
     */
    'height': string;
    /**
     * 
     * @type {string}
     * @memberof FinalizationProofDTO
     */
    'hash': string;
    /**
     * 
     * @type {Array<MessageGroup>}
     * @memberof FinalizationProofDTO
     */
    'messageGroups': Array<MessageGroup>;
}
/**
 * 
 * @export
 * @interface FinalizedBlockDTO
 */
export interface FinalizedBlockDTO {
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof FinalizedBlockDTO
     */
    'finalizationEpoch': number;
    /**
     * Finalization point
     * @type {number}
     * @memberof FinalizedBlockDTO
     */
    'finalizationPoint': number;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof FinalizedBlockDTO
     */
    'height': string;
    /**
     * 
     * @type {string}
     * @memberof FinalizedBlockDTO
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface HashLockEntryDTO
 */
export interface HashLockEntryDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof HashLockEntryDTO
     */
    'version': number;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof HashLockEntryDTO
     */
    'ownerAddress': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof HashLockEntryDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof HashLockEntryDTO
     */
    'amount': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof HashLockEntryDTO
     */
    'endHeight': string;
    /**
     * 
     * @type {LockStatus}
     * @memberof HashLockEntryDTO
     */
    'status': LockStatus;
    /**
     * 
     * @type {string}
     * @memberof HashLockEntryDTO
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface HashLockInfoDTO
 */
export interface HashLockInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof HashLockInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {HashLockEntryDTO}
     * @memberof HashLockInfoDTO
     */
    'lock': HashLockEntryDTO;
}
/**
 * 
 * @export
 * @interface HashLockNetworkPropertiesDTO
 */
export interface HashLockNetworkPropertiesDTO {
    /**
     * Amount that has to be locked per aggregate in partial cache.
     * @type {string}
     * @memberof HashLockNetworkPropertiesDTO
     */
    'lockedFundsPerAggregate'?: string;
    /**
     * Maximum number of blocks for which a hash lock can exist.
     * @type {string}
     * @memberof HashLockNetworkPropertiesDTO
     */
    'maxHashLockDuration'?: string;
}
/**
 * 
 * @export
 * @interface HashLockPage
 */
export interface HashLockPage {
    /**
     * Array of hash locks.
     * @type {Array<HashLockInfoDTO>}
     * @memberof HashLockPage
     */
    'data': Array<HashLockInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof HashLockPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface HashLockTransactionBodyDTO
 */
export interface HashLockTransactionBodyDTO {
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof HashLockTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof HashLockTransactionBodyDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof HashLockTransactionBodyDTO
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof HashLockTransactionBodyDTO
     */
    'hash': string;
}
/**
 * Transaction to lock funds before sending an aggregate bonded transaction.
 * @export
 * @interface HashLockTransactionDTO
 */
export interface HashLockTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof HashLockTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof HashLockTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof HashLockTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof HashLockTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'deadline': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof HashLockTransactionDTO
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface ImportanceBlockDTO
 */
export interface ImportanceBlockDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof ImportanceBlockDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof ImportanceBlockDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof ImportanceBlockDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ImportanceBlockDTO
     */
    'type': number;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'height': string;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'timestamp': string;
    /**
     * Determines how hard is to harvest a new block, based on previous blocks.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'difficulty': string;
    /**
     * 32-bytes VRF proof gamma.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'proofGamma': string;
    /**
     * 16-bytes VRF proof verification hash.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'proofVerificationHash': string;
    /**
     * 32-bytes VRF proof scalar.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'proofScalar': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'previousBlockHash': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'transactionsHash': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'receiptsHash': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'stateHash': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'beneficiaryAddress': string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof ImportanceBlockDTO
     */
    'feeMultiplier': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof ImportanceBlockDTO
     */
    'votingEligibleAccountsCount': number;
    /**
     * A number that allows uint 64 values represented with a string.
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'harvestingEligibleAccountsCount': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'totalVotingBalance': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTO
     */
    'previousImportanceBlockHash': string;
}
/**
 * 
 * @export
 * @interface ImportanceBlockDTOAllOf
 */
export interface ImportanceBlockDTOAllOf {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof ImportanceBlockDTOAllOf
     */
    'votingEligibleAccountsCount': number;
    /**
     * A number that allows uint 64 values represented with a string.
     * @type {string}
     * @memberof ImportanceBlockDTOAllOf
     */
    'harvestingEligibleAccountsCount': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof ImportanceBlockDTOAllOf
     */
    'totalVotingBalance': string;
    /**
     * 
     * @type {string}
     * @memberof ImportanceBlockDTOAllOf
     */
    'previousImportanceBlockHash': string;
}
/**
 * Receipt stored when network currency mosaics were created due to inflation.
 * @export
 * @interface InflationReceiptDTO
 */
export interface InflationReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof InflationReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof InflationReceiptDTO
     */
    'type': ReceiptTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof InflationReceiptDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof InflationReceiptDTO
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface InflationReceiptDTOAllOf
 */
export interface InflationReceiptDTOAllOf {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof InflationReceiptDTOAllOf
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof InflationReceiptDTOAllOf
     */
    'amount': string;
}
/**
 * Type of action: * 0 - Unlink. * 1 - Link. 
 * @export
 * @enum {string}
 */

export const LinkActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type LinkActionEnum = typeof LinkActionEnum[keyof typeof LinkActionEnum];


/**
 * Algorithm used to hash the proof: * 0 (Op_Sha3_256) - Proof is hashed using SHA3-256. * 1 (Op_Hash_160) - Proof is hashed twice: first with SHA-256 and then with RIPEMD-160 (bitcoin\'s OP_HASH160). * 2 (Op_Hash_256) - Proof is hashed twice with SHA3-256 (bitcoin\'s OP_HASH256). 
 * @export
 * @enum {string}
 */

export const LockHashAlgorithmEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type LockHashAlgorithmEnum = typeof LockHashAlgorithmEnum[keyof typeof LockHashAlgorithmEnum];


/**
 * Possible status of lock states: * 0 - UNUSED. * 1 - USED. 
 * @export
 * @enum {string}
 */

export const LockStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type LockStatus = typeof LockStatus[keyof typeof LockStatus];


/**
 * Each merkle path item is composed of a hash, and a position relative to the proofHash being evaluated.
 * @export
 * @interface MerklePathItemDTO
 */
export interface MerklePathItemDTO {
    /**
     * 
     * @type {PositionEnum}
     * @memberof MerklePathItemDTO
     */
    'position'?: PositionEnum;
    /**
     * 
     * @type {string}
     * @memberof MerklePathItemDTO
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface MerkleProofInfoDTO
 */
export interface MerkleProofInfoDTO {
    /**
     * List of complementary merkle path items needed to recalculate the merkle root.
     * @type {Array<MerklePathItemDTO>}
     * @memberof MerkleProofInfoDTO
     */
    'merklePath'?: Array<MerklePathItemDTO>;
}
/**
 * The merkle path information clients can use to proof the state of the given entity. 
 * @export
 * @interface MerkleStateInfoDTO
 */
export interface MerkleStateInfoDTO {
    /**
     * The hex information of the complete merkle tree as returned by server api. More information can be found in chapter 4.3 of the catapult whitepaper. 
     * @type {string}
     * @memberof MerkleStateInfoDTO
     */
    'raw': string;
    /**
     * Merkle tree parsed from merkle tree raw.
     * @type {Array<MerkleStateInfoDTOTreeInner>}
     * @memberof MerkleStateInfoDTO
     */
    'tree': Array<MerkleStateInfoDTOTreeInner>;
}
/**
 * 
 * @export
 * @interface MerkleStateInfoDTOTreeInner
 */
export interface MerkleStateInfoDTOTreeInner {
    /**
     * 
     * @type {MerkleTreeNodeTypeEnum}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'type': MerkleTreeNodeTypeEnum;
    /**
     * Leaf path.
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'path': string;
    /**
     * Encoded leaf path.
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'encodedPath': string;
    /**
     * Nibble count.
     * @type {number}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'nibbleCount': number;
    /**
     * Branch link bitmask.
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'linkMask': string;
    /**
     * Branch links (max 16).
     * @type {Array<MerkleTreeBranchLinkDTO>}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'links': Array<MerkleTreeBranchLinkDTO>;
    /**
     * 
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'branchHash': string;
    /**
     * Leaf value (sha256 hash).
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof MerkleStateInfoDTOTreeInner
     */
    'leafHash': string;
}
/**
 * Merkle tree branch node.
 * @export
 * @interface MerkleTreeBranchDTO
 */
export interface MerkleTreeBranchDTO {
    /**
     * 
     * @type {MerkleTreeNodeTypeEnum}
     * @memberof MerkleTreeBranchDTO
     */
    'type': MerkleTreeNodeTypeEnum;
    /**
     * Branch link path.
     * @type {string}
     * @memberof MerkleTreeBranchDTO
     */
    'path': string;
    /**
     * Encoded branch link path.
     * @type {string}
     * @memberof MerkleTreeBranchDTO
     */
    'encodedPath': string;
    /**
     * Nibble count.
     * @type {number}
     * @memberof MerkleTreeBranchDTO
     */
    'nibbleCount': number;
    /**
     * Branch link bitmask.
     * @type {string}
     * @memberof MerkleTreeBranchDTO
     */
    'linkMask': string;
    /**
     * Branch links (max 16).
     * @type {Array<MerkleTreeBranchLinkDTO>}
     * @memberof MerkleTreeBranchDTO
     */
    'links': Array<MerkleTreeBranchLinkDTO>;
    /**
     * 
     * @type {string}
     * @memberof MerkleTreeBranchDTO
     */
    'branchHash': string;
}
/**
 * Merkle tree branch link.
 * @export
 * @interface MerkleTreeBranchLinkDTO
 */
export interface MerkleTreeBranchLinkDTO {
    /**
     * Branch link nibble bit index (hexadecimal).
     * @type {string}
     * @memberof MerkleTreeBranchLinkDTO
     */
    'bit': string;
    /**
     * 
     * @type {string}
     * @memberof MerkleTreeBranchLinkDTO
     */
    'link': string;
}
/**
 * Merkle tree leaf node.
 * @export
 * @interface MerkleTreeLeafDTO
 */
export interface MerkleTreeLeafDTO {
    /**
     * 
     * @type {MerkleTreeNodeTypeEnum}
     * @memberof MerkleTreeLeafDTO
     */
    'type': MerkleTreeNodeTypeEnum;
    /**
     * Leaf path.
     * @type {string}
     * @memberof MerkleTreeLeafDTO
     */
    'path': string;
    /**
     * Encoded leaf path.
     * @type {string}
     * @memberof MerkleTreeLeafDTO
     */
    'encodedPath': string;
    /**
     * Nibble count.
     * @type {number}
     * @memberof MerkleTreeLeafDTO
     */
    'nibbleCount': number;
    /**
     * Leaf value (sha256 hash).
     * @type {string}
     * @memberof MerkleTreeLeafDTO
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof MerkleTreeLeafDTO
     */
    'leafHash': string;
}
/**
 * Type of Merkle tree node: * 0 - Branch node. * 255 - Leaf node. 
 * @export
 * @enum {string}
 */

export const MerkleTreeNodeTypeEnum = {
    NUMBER_0: 0,
    NUMBER_255: 255
} as const;

export type MerkleTreeNodeTypeEnum = typeof MerkleTreeNodeTypeEnum[keyof typeof MerkleTreeNodeTypeEnum];


/**
 * 
 * @export
 * @interface MessageGroup
 */
export interface MessageGroup {
    /**
     * 
     * @type {StageEnum}
     * @memberof MessageGroup
     */
    'stage': StageEnum;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof MessageGroup
     */
    'height': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageGroup
     */
    'hashes': Array<string>;
    /**
     * 
     * @type {Array<BmTreeSignature>}
     * @memberof MessageGroup
     */
    'signatures': Array<BmTreeSignature>;
}
/**
 * 
 * @export
 * @interface MetadataEntryDTO
 */
export interface MetadataEntryDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof MetadataEntryDTO
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof MetadataEntryDTO
     */
    'compositeHash': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MetadataEntryDTO
     */
    'sourceAddress': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MetadataEntryDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof MetadataEntryDTO
     */
    'scopedMetadataKey': string;
    /**
     * 
     * @type {MetadataEntryDTOTargetId}
     * @memberof MetadataEntryDTO
     */
    'targetId'?: MetadataEntryDTOTargetId;
    /**
     * 
     * @type {MetadataTypeEnum}
     * @memberof MetadataEntryDTO
     */
    'metadataType': MetadataTypeEnum;
    /**
     * Metadata value.
     * @type {string}
     * @memberof MetadataEntryDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MetadataEntryDTOTargetId
 */
export interface MetadataEntryDTOTargetId {
}
/**
 * 
 * @export
 * @interface MetadataInfoDTO
 */
export interface MetadataInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof MetadataInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {MetadataEntryDTO}
     * @memberof MetadataInfoDTO
     */
    'metadataEntry': MetadataEntryDTO;
}
/**
 * 
 * @export
 * @interface MetadataNetworkPropertiesDTO
 */
export interface MetadataNetworkPropertiesDTO {
    /**
     * Maximum metadata value size.
     * @type {string}
     * @memberof MetadataNetworkPropertiesDTO
     */
    'maxValueSize'?: string;
}
/**
 * 
 * @export
 * @interface MetadataPage
 */
export interface MetadataPage {
    /**
     * Array of metadata entries.
     * @type {Array<MetadataInfoDTO>}
     * @memberof MetadataPage
     */
    'data': Array<MetadataInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof MetadataPage
     */
    'pagination': Pagination;
}
/**
 * Metadata type: * 0 - Account. * 1 - Mosaic. * 2 - Namespace. 
 * @export
 * @enum {string}
 */

export const MetadataTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type MetadataTypeEnum = typeof MetadataTypeEnum[keyof typeof MetadataTypeEnum];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface Mosaic
 */
export interface Mosaic {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof Mosaic
     */
    'id': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof Mosaic
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface MosaicAddressRestrictionDTO
 */
export interface MosaicAddressRestrictionDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof MosaicAddressRestrictionDTO
     */
    'id': string;
    /**
     * 
     * @type {MosaicAddressRestrictionEntryWrapperDTO}
     * @memberof MosaicAddressRestrictionDTO
     */
    'mosaicRestrictionEntry': MosaicAddressRestrictionEntryWrapperDTO;
}
/**
 * 
 * @export
 * @interface MosaicAddressRestrictionEntryDTO
 */
export interface MosaicAddressRestrictionEntryDTO {
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicAddressRestrictionEntryDTO
     */
    'key': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicAddressRestrictionEntryDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MosaicAddressRestrictionEntryWrapperDTO
 */
export interface MosaicAddressRestrictionEntryWrapperDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'compositeHash': string;
    /**
     * 
     * @type {MosaicRestrictionEntryTypeEnum}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'entryType': MosaicRestrictionEntryTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'mosaicId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'targetAddress': string;
    /**
     * 
     * @type {Array<MosaicAddressRestrictionEntryDTO>}
     * @memberof MosaicAddressRestrictionEntryWrapperDTO
     */
    'restrictions': Array<MosaicAddressRestrictionEntryDTO>;
}
/**
 * 
 * @export
 * @interface MosaicAddressRestrictionTransactionBodyDTO
 */
export interface MosaicAddressRestrictionTransactionBodyDTO {
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionBodyDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionBodyDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionBodyDTO
     */
    'newRestrictionValue': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionBodyDTO
     */
    'targetAddress': string;
}
/**
 * Transaction to set a restriction rule to an address.
 * @export
 * @interface MosaicAddressRestrictionTransactionDTO
 */
export interface MosaicAddressRestrictionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'deadline': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'mosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'newRestrictionValue': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicAddressRestrictionTransactionDTO
     */
    'targetAddress': string;
}
/**
 * 
 * @export
 * @interface MosaicAliasTransactionBodyDTO
 */
export interface MosaicAliasTransactionBodyDTO {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof MosaicAliasTransactionBodyDTO
     */
    'namespaceId': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicAliasTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof MosaicAliasTransactionBodyDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * Transaction to link a namespace to a mosaic.
 * @export
 * @interface MosaicAliasTransactionDTO
 */
export interface MosaicAliasTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicAliasTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicAliasTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicAliasTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicAliasTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'deadline': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'namespaceId': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicAliasTransactionDTO
     */
    'mosaicId': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof MosaicAliasTransactionDTO
     */
    'aliasAction': AliasActionEnum;
}
/**
 * 
 * @export
 * @interface MosaicDTO
 */
export interface MosaicDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof MosaicDTO
     */
    'version': number;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicDTO
     */
    'id': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicDTO
     */
    'supply': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof MosaicDTO
     */
    'startHeight': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MosaicDTO
     */
    'ownerAddress': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicDTO
     */
    'revision': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof MosaicDTO
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof MosaicDTO
     */
    'divisibility': number;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicDTO
     */
    'duration': string;
}
/**
 * 
 * @export
 * @interface MosaicDefinitionTransactionBodyDTO
 */
export interface MosaicDefinitionTransactionBodyDTO {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicDefinitionTransactionBodyDTO
     */
    'id': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicDefinitionTransactionBodyDTO
     */
    'duration': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicDefinitionTransactionBodyDTO
     */
    'nonce': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof MosaicDefinitionTransactionBodyDTO
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof MosaicDefinitionTransactionBodyDTO
     */
    'divisibility': number;
}
/**
 * Transaction to create a new mosaic.
 * @export
 * @interface MosaicDefinitionTransactionDTO
 */
export interface MosaicDefinitionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'deadline': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'id': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'duration': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'nonce': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof MosaicDefinitionTransactionDTO
     */
    'divisibility': number;
}
/**
 * Receipt stored when a mosaic expires.
 * @export
 * @interface MosaicExpiryReceiptDTO
 */
export interface MosaicExpiryReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof MosaicExpiryReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof MosaicExpiryReceiptDTO
     */
    'type': ReceiptTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicExpiryReceiptDTO
     */
    'artifactId': string;
}
/**
 * 
 * @export
 * @interface MosaicExpiryReceiptDTOAllOf
 */
export interface MosaicExpiryReceiptDTOAllOf {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicExpiryReceiptDTOAllOf
     */
    'artifactId': string;
}
/**
 * 
 * @export
 * @interface MosaicGlobalRestrictionDTO
 */
export interface MosaicGlobalRestrictionDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof MosaicGlobalRestrictionDTO
     */
    'id': string;
    /**
     * 
     * @type {MosaicGlobalRestrictionEntryWrapperDTO}
     * @memberof MosaicGlobalRestrictionDTO
     */
    'mosaicRestrictionEntry': MosaicGlobalRestrictionEntryWrapperDTO;
}
/**
 * 
 * @export
 * @interface MosaicGlobalRestrictionEntryDTO
 */
export interface MosaicGlobalRestrictionEntryDTO {
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicGlobalRestrictionEntryDTO
     */
    'key': string;
    /**
     * 
     * @type {MosaicGlobalRestrictionEntryRestrictionDTO}
     * @memberof MosaicGlobalRestrictionEntryDTO
     */
    'restriction': MosaicGlobalRestrictionEntryRestrictionDTO;
}
/**
 * 
 * @export
 * @interface MosaicGlobalRestrictionEntryRestrictionDTO
 */
export interface MosaicGlobalRestrictionEntryRestrictionDTO {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicGlobalRestrictionEntryRestrictionDTO
     */
    'referenceMosaicId': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicGlobalRestrictionEntryRestrictionDTO
     */
    'restrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof MosaicGlobalRestrictionEntryRestrictionDTO
     */
    'restrictionType': MosaicRestrictionTypeEnum;
}
/**
 * 
 * @export
 * @interface MosaicGlobalRestrictionEntryWrapperDTO
 */
export interface MosaicGlobalRestrictionEntryWrapperDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof MosaicGlobalRestrictionEntryWrapperDTO
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof MosaicGlobalRestrictionEntryWrapperDTO
     */
    'compositeHash': string;
    /**
     * 
     * @type {MosaicRestrictionEntryTypeEnum}
     * @memberof MosaicGlobalRestrictionEntryWrapperDTO
     */
    'entryType': MosaicRestrictionEntryTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicGlobalRestrictionEntryWrapperDTO
     */
    'mosaicId': string;
    /**
     * 
     * @type {Array<MosaicGlobalRestrictionEntryDTO>}
     * @memberof MosaicGlobalRestrictionEntryWrapperDTO
     */
    'restrictions': Array<MosaicGlobalRestrictionEntryDTO>;
}
/**
 * 
 * @export
 * @interface MosaicGlobalRestrictionTransactionBodyDTO
 */
export interface MosaicGlobalRestrictionTransactionBodyDTO {
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'referenceMosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'newRestrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'previousRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof MosaicGlobalRestrictionTransactionBodyDTO
     */
    'newRestrictionType': MosaicRestrictionTypeEnum;
}
/**
 * Transaction to set a network-wide restriction rule to a mosaic.
 * @export
 * @interface MosaicGlobalRestrictionTransactionDTO
 */
export interface MosaicGlobalRestrictionTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'deadline': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'mosaicId': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'referenceMosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'newRestrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'previousRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof MosaicGlobalRestrictionTransactionDTO
     */
    'newRestrictionType': MosaicRestrictionTypeEnum;
}
/**
 * 
 * @export
 * @interface MosaicIds
 */
export interface MosaicIds {
    /**
     * Array of mosaic identifiers.
     * @type {Array<string>}
     * @memberof MosaicIds
     */
    'mosaicIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MosaicInfoDTO
 */
export interface MosaicInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof MosaicInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {MosaicDTO}
     * @memberof MosaicInfoDTO
     */
    'mosaic': MosaicDTO;
}
/**
 * 
 * @export
 * @interface MosaicMetadataTransactionBodyDTO
 */
export interface MosaicMetadataTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'scopedMetadataKey': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'targetMosaicId': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof MosaicMetadataTransactionBodyDTO
     */
    'value': string;
}
/**
 * Transaction to create or modify a multisig account.
 * @export
 * @interface MosaicMetadataTransactionDTO
 */
export interface MosaicMetadataTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicMetadataTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicMetadataTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'targetMosaicId': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof MosaicMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof MosaicMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MosaicNamesDTO
 */
export interface MosaicNamesDTO {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicNamesDTO
     */
    'mosaicId': string;
    /**
     * Mosaic linked namespace names.
     * @type {Array<string>}
     * @memberof MosaicNamesDTO
     */
    'names': Array<string>;
}
/**
 * 
 * @export
 * @interface MosaicNetworkPropertiesDTO
 */
export interface MosaicNetworkPropertiesDTO {
    /**
     * Maximum number of mosaics that an account can own.
     * @type {string}
     * @memberof MosaicNetworkPropertiesDTO
     */
    'maxMosaicsPerAccount'?: string;
    /**
     * Maximum mosaic duration.
     * @type {string}
     * @memberof MosaicNetworkPropertiesDTO
     */
    'maxMosaicDuration'?: string;
    /**
     * Maximum mosaic divisibility.
     * @type {string}
     * @memberof MosaicNetworkPropertiesDTO
     */
    'maxMosaicDivisibility'?: string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MosaicNetworkPropertiesDTO
     */
    'mosaicRentalFeeSinkAddress'?: string;
    /**
     * Mosaic rental fee.
     * @type {string}
     * @memberof MosaicNetworkPropertiesDTO
     */
    'mosaicRentalFee'?: string;
}
/**
 * 
 * @export
 * @interface MosaicPage
 */
export interface MosaicPage {
    /**
     * Array of mosaics.
     * @type {Array<MosaicInfoDTO>}
     * @memberof MosaicPage
     */
    'data': Array<MosaicInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof MosaicPage
     */
    'pagination': Pagination;
}
/**
 * Generic Mosaic Restriction
 * @export
 * @interface MosaicRestrictionDTO
 */
export interface MosaicRestrictionDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof MosaicRestrictionDTO
     */
    'id': string;
    /**
     * 
     * @type {MosaicGlobalRestrictionEntryWrapperDTO}
     * @memberof MosaicRestrictionDTO
     */
    'mosaicRestrictionEntry': MosaicGlobalRestrictionEntryWrapperDTO;
}
/**
 * - 0 - Mosaic address restriction. - 1 - Mosaic global restriction. 
 * @export
 * @enum {string}
 */

export const MosaicRestrictionEntryTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MosaicRestrictionEntryTypeEnum = typeof MosaicRestrictionEntryTypeEnum[keyof typeof MosaicRestrictionEntryTypeEnum];


/**
 * 
 * @export
 * @interface MosaicRestrictionNetworkPropertiesDTO
 */
export interface MosaicRestrictionNetworkPropertiesDTO {
    /**
     * Maximum number of mosaic restriction values.
     * @type {string}
     * @memberof MosaicRestrictionNetworkPropertiesDTO
     */
    'maxMosaicRestrictionValues'?: string;
}
/**
 * Type of mosaic restriction. * 0 - Uninitialized value indicating no restriction. * 1 (EQ) - Allow if equal. * 2 (NE) - Allow if not equal. * 3 (LT) - Allow if less than. * 4 (LE) - Allow if less than or equal. * 5 (GT) - Allow if greater than. * 6 (GE) - Allow if greater than or equal. 
 * @export
 * @enum {string}
 */

export const MosaicRestrictionTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type MosaicRestrictionTypeEnum = typeof MosaicRestrictionTypeEnum[keyof typeof MosaicRestrictionTypeEnum];


/**
 * 
 * @export
 * @interface MosaicRestrictionsPage
 */
export interface MosaicRestrictionsPage {
    /**
     * Array of mosaic restrictions.
     * @type {Array<MosaicRestrictionsPageDataInner>}
     * @memberof MosaicRestrictionsPage
     */
    'data': Array<MosaicRestrictionsPageDataInner>;
    /**
     * 
     * @type {Pagination}
     * @memberof MosaicRestrictionsPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface MosaicRestrictionsPageDataInner
 */
export interface MosaicRestrictionsPageDataInner {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof MosaicRestrictionsPageDataInner
     */
    'id': string;
    /**
     * 
     * @type {MosaicGlobalRestrictionEntryWrapperDTO}
     * @memberof MosaicRestrictionsPageDataInner
     */
    'mosaicRestrictionEntry': MosaicGlobalRestrictionEntryWrapperDTO;
}
/**
 * Direction of the supply change: * 0  - Decrease. * 1  - Increase. 
 * @export
 * @enum {string}
 */

export const MosaicSupplyChangeActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type MosaicSupplyChangeActionEnum = typeof MosaicSupplyChangeActionEnum[keyof typeof MosaicSupplyChangeActionEnum];


/**
 * 
 * @export
 * @interface MosaicSupplyChangeTransactionBodyDTO
 */
export interface MosaicSupplyChangeTransactionBodyDTO {
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionBodyDTO
     */
    'delta': string;
    /**
     * 
     * @type {MosaicSupplyChangeActionEnum}
     * @memberof MosaicSupplyChangeTransactionBodyDTO
     */
    'action': MosaicSupplyChangeActionEnum;
}
/**
 * Transaction to increase or decrease the supply of a mosaic.
 * @export
 * @interface MosaicSupplyChangeTransactionDTO
 */
export interface MosaicSupplyChangeTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'deadline': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'delta': string;
    /**
     * 
     * @type {MosaicSupplyChangeActionEnum}
     * @memberof MosaicSupplyChangeTransactionDTO
     */
    'action': MosaicSupplyChangeActionEnum;
}
/**
 * 
 * @export
 * @interface MosaicSupplyRevocationTransactionBodyDTO
 */
export interface MosaicSupplyRevocationTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionBodyDTO
     */
    'sourceAddress': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionBodyDTO
     */
    'amount': string;
}
/**
 * Transaction that allows the mosaic creator to revoke some balance from a user.
 * @export
 * @interface MosaicSupplyRevocationTransactionDTO
 */
export interface MosaicSupplyRevocationTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'sourceAddress': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MosaicSupplyRevocationTransactionDTO
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface MosaicsNamesDTO
 */
export interface MosaicsNamesDTO {
    /**
     * Array of mosaic names.
     * @type {Array<MosaicNamesDTO>}
     * @memberof MosaicsNamesDTO
     */
    'mosaicNames': Array<MosaicNamesDTO>;
}
/**
 * 
 * @export
 * @interface MultisigAccountGraphInfoDTO
 */
export interface MultisigAccountGraphInfoDTO {
    /**
     * Level of the multisig account.
     * @type {number}
     * @memberof MultisigAccountGraphInfoDTO
     */
    'level': number;
    /**
     * Array of multisig accounts for this level.
     * @type {Array<MultisigAccountInfoDTO>}
     * @memberof MultisigAccountGraphInfoDTO
     */
    'multisigEntries': Array<MultisigAccountInfoDTO>;
}
/**
 * 
 * @export
 * @interface MultisigAccountInfoDTO
 */
export interface MultisigAccountInfoDTO {
    /**
     * 
     * @type {MultisigDTO}
     * @memberof MultisigAccountInfoDTO
     */
    'multisig': MultisigDTO;
}
/**
 * 
 * @export
 * @interface MultisigAccountModificationTransactionBodyDTO
 */
export interface MultisigAccountModificationTransactionBodyDTO {
    /**
     * Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof MultisigAccountModificationTransactionBodyDTO
     */
    'minRemovalDelta': number;
    /**
     * Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof MultisigAccountModificationTransactionBodyDTO
     */
    'minApprovalDelta': number;
    /**
     * Array of cosignatory accounts to add.
     * @type {Array<string>}
     * @memberof MultisigAccountModificationTransactionBodyDTO
     */
    'addressAdditions': Array<string>;
    /**
     * Array of cosignatory accounts to delete.
     * @type {Array<string>}
     * @memberof MultisigAccountModificationTransactionBodyDTO
     */
    'addressDeletions': Array<string>;
}
/**
 * Transaction to create or modify a multisig account.
 * @export
 * @interface MultisigAccountModificationTransactionDTO
 */
export interface MultisigAccountModificationTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'deadline': string;
    /**
     * Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'minRemovalDelta': number;
    /**
     * Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'minApprovalDelta': number;
    /**
     * Array of cosignatory accounts to add.
     * @type {Array<string>}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'addressAdditions': Array<string>;
    /**
     * Array of cosignatory accounts to delete.
     * @type {Array<string>}
     * @memberof MultisigAccountModificationTransactionDTO
     */
    'addressDeletions': Array<string>;
}
/**
 * 
 * @export
 * @interface MultisigDTO
 */
export interface MultisigDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof MultisigDTO
     */
    'version': number;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof MultisigDTO
     */
    'accountAddress': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MultisigDTO
     */
    'minApproval': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof MultisigDTO
     */
    'minRemoval': number;
    /**
     * Addresses of the cosignatory accounts.
     * @type {Array<string>}
     * @memberof MultisigDTO
     */
    'cosignatoryAddresses': Array<string>;
    /**
     * Multisig accounts where the account is cosignatory.
     * @type {Array<string>}
     * @memberof MultisigDTO
     */
    'multisigAddresses': Array<string>;
}
/**
 * 
 * @export
 * @interface MultisigNetworkPropertiesDTO
 */
export interface MultisigNetworkPropertiesDTO {
    /**
     * Maximum number of multisig levels.
     * @type {string}
     * @memberof MultisigNetworkPropertiesDTO
     */
    'maxMultisigDepth'?: string;
    /**
     * Maximum number of cosignatories per account.
     * @type {string}
     * @memberof MultisigNetworkPropertiesDTO
     */
    'maxCosignatoriesPerAccount'?: string;
    /**
     * Maximum number of accounts a single account can cosign.
     * @type {string}
     * @memberof MultisigNetworkPropertiesDTO
     */
    'maxCosignedAccountsPerAccount'?: string;
}
/**
 * 
 * @export
 * @interface NamespaceDTO
 */
export interface NamespaceDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof NamespaceDTO
     */
    'version': number;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof NamespaceDTO
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Level of the namespace.
     * @type {number}
     * @memberof NamespaceDTO
     */
    'depth': number;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'level0': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'level1'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'level2'?: string;
    /**
     * 
     * @type {AliasDTO}
     * @memberof NamespaceDTO
     */
    'alias': AliasDTO;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'parentId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'ownerAddress': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'startHeight': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof NamespaceDTO
     */
    'endHeight': string;
}
/**
 * Receipt stored when a namespace expires.
 * @export
 * @interface NamespaceExpiryReceiptDTO
 */
export interface NamespaceExpiryReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof NamespaceExpiryReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof NamespaceExpiryReceiptDTO
     */
    'type': ReceiptTypeEnum;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceExpiryReceiptDTO
     */
    'artifactId': string;
}
/**
 * 
 * @export
 * @interface NamespaceExpiryReceiptDTOAllOf
 */
export interface NamespaceExpiryReceiptDTOAllOf {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceExpiryReceiptDTOAllOf
     */
    'artifactId': string;
}
/**
 * 
 * @export
 * @interface NamespaceIds
 */
export interface NamespaceIds {
    /**
     * Array of namespace identifiers.
     * @type {Array<string>}
     * @memberof NamespaceIds
     */
    'namespaceIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NamespaceInfoDTO
 */
export interface NamespaceInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof NamespaceInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {NamespaceMetaDTO}
     * @memberof NamespaceInfoDTO
     */
    'meta': NamespaceMetaDTO;
    /**
     * 
     * @type {NamespaceDTO}
     * @memberof NamespaceInfoDTO
     */
    'namespace': NamespaceDTO;
}
/**
 * 
 * @export
 * @interface NamespaceMetaDTO
 */
export interface NamespaceMetaDTO {
    /**
     * If true, the namespace is active.
     * @type {boolean}
     * @memberof NamespaceMetaDTO
     */
    'active': boolean;
    /**
     * 
     * @type {number}
     * @memberof NamespaceMetaDTO
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface NamespaceMetadataTransactionBodyDTO
 */
export interface NamespaceMetadataTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'scopedMetadataKey': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'targetNamespaceId'?: string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof NamespaceMetadataTransactionBodyDTO
     */
    'value': string;
}
/**
 * Transaction to create or modify a multisig account.
 * @export
 * @interface NamespaceMetadataTransactionDTO
 */
export interface NamespaceMetadataTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'scopedMetadataKey': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'targetNamespaceId'?: string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof NamespaceMetadataTransactionDTO
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface NamespaceNameDTO
 */
export interface NamespaceNameDTO {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceNameDTO
     */
    'parentId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceNameDTO
     */
    'id': string;
    /**
     * Namespace name.
     * @type {string}
     * @memberof NamespaceNameDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NamespaceNetworkPropertiesDTO
 */
export interface NamespaceNetworkPropertiesDTO {
    /**
     * Maximum namespace name size.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'maxNameSize'?: string;
    /**
     * Maximum number of children for a root namespace.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'maxChildNamespaces'?: string;
    /**
     * Maximum namespace depth.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'maxNamespaceDepth'?: string;
    /**
     * Minimum namespace duration.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'minNamespaceDuration'?: string;
    /**
     * Maximum namespace duration.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'maxNamespaceDuration'?: string;
    /**
     * Grace period during which time only the previous owner can renew an expired namespace.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'namespaceGracePeriodDuration'?: string;
    /**
     * Reserved root namespaces that cannot be claimed.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'reservedRootNamespaceNames'?: string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'namespaceRentalFeeSinkAddress'?: string;
    /**
     * Root namespace rental fee per block.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'rootNamespaceRentalFeePerBlock'?: string;
    /**
     * Child namespace rental fee.
     * @type {string}
     * @memberof NamespaceNetworkPropertiesDTO
     */
    'childNamespaceRentalFee'?: string;
}
/**
 * 
 * @export
 * @interface NamespacePage
 */
export interface NamespacePage {
    /**
     * Array of namespaces.
     * @type {Array<NamespaceInfoDTO>}
     * @memberof NamespacePage
     */
    'data': Array<NamespaceInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof NamespacePage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface NamespaceRegistrationTransactionBodyDTO
 */
export interface NamespaceRegistrationTransactionBodyDTO {
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionBodyDTO
     */
    'duration'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionBodyDTO
     */
    'parentId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionBodyDTO
     */
    'id': string;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof NamespaceRegistrationTransactionBodyDTO
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Namespace name.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionBodyDTO
     */
    'name': string;
}
/**
 * Transaction to create or renew a namespace.
 * @export
 * @interface NamespaceRegistrationTransactionDTO
 */
export interface NamespaceRegistrationTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'deadline': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'duration'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'parentId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'id': string;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Namespace name.
     * @type {string}
     * @memberof NamespaceRegistrationTransactionDTO
     */
    'name': string;
}
/**
 * Type of namespace: * 0 - Root namespace. * 1 - Subnamespace. 
 * @export
 * @enum {string}
 */

export const NamespaceRegistrationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type NamespaceRegistrationTypeEnum = typeof NamespaceRegistrationTypeEnum[keyof typeof NamespaceRegistrationTypeEnum];


/**
 * 
 * @export
 * @interface NetworkConfigurationDTO
 */
export interface NetworkConfigurationDTO {
    /**
     * 
     * @type {NetworkPropertiesDTO}
     * @memberof NetworkConfigurationDTO
     */
    'network': NetworkPropertiesDTO;
    /**
     * 
     * @type {ChainPropertiesDTO}
     * @memberof NetworkConfigurationDTO
     */
    'chain': ChainPropertiesDTO;
    /**
     * 
     * @type {PluginsPropertiesDTO}
     * @memberof NetworkConfigurationDTO
     */
    'plugins': PluginsPropertiesDTO;
}
/**
 * Network related configuration properties.
 * @export
 * @interface NetworkPropertiesDTO
 */
export interface NetworkPropertiesDTO {
    /**
     * Network identifier.
     * @type {string}
     * @memberof NetworkPropertiesDTO
     */
    'identifier'?: string;
    /**
     * 
     * @type {NodeIdentityEqualityStrategy}
     * @memberof NetworkPropertiesDTO
     */
    'nodeEqualityStrategy'?: NodeIdentityEqualityStrategy;
    /**
     * Public key.
     * @type {string}
     * @memberof NetworkPropertiesDTO
     */
    'nemesisSignerPublicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkPropertiesDTO
     */
    'generationHashSeed'?: string;
    /**
     * Nemesis epoch time adjustment.
     * @type {string}
     * @memberof NetworkPropertiesDTO
     */
    'epochAdjustment'?: string;
}
/**
 * 
 * @export
 * @interface NetworkTypeDTO
 */
export interface NetworkTypeDTO {
    /**
     * Network name.
     * @type {string}
     * @memberof NetworkTypeDTO
     */
    'name': string;
    /**
     * A short text describing the network.
     * @type {string}
     * @memberof NetworkTypeDTO
     */
    'description': string;
}
/**
 * Network type: * 0x68 (104 decimal) - Main network. * 0x98 (152 decimal) - Test network. 
 * @export
 * @enum {string}
 */

export const NetworkTypeEnum = {
    NUMBER_104: 104,
    NUMBER_152: 152
} as const;

export type NetworkTypeEnum = typeof NetworkTypeEnum[keyof typeof NetworkTypeEnum];


/**
 * 
 * @export
 * @interface NodeHealthDTO
 */
export interface NodeHealthDTO {
    /**
     * 
     * @type {NodeStatusEnum}
     * @memberof NodeHealthDTO
     */
    'apiNode': NodeStatusEnum;
    /**
     * 
     * @type {NodeStatusEnum}
     * @memberof NodeHealthDTO
     */
    'db': NodeStatusEnum;
}
/**
 * 
 * @export
 * @interface NodeHealthInfoDTO
 */
export interface NodeHealthInfoDTO {
    /**
     * 
     * @type {NodeHealthDTO}
     * @memberof NodeHealthInfoDTO
     */
    'status': NodeHealthDTO;
}
/**
 * Node equality strategy. Defines if the identifier for the node must be its public key or host. 
 * @export
 * @enum {string}
 */

export const NodeIdentityEqualityStrategy = {
    Host: 'host',
    PublicKey: 'public-key'
} as const;

export type NodeIdentityEqualityStrategy = typeof NodeIdentityEqualityStrategy[keyof typeof NodeIdentityEqualityStrategy];


/**
 * 
 * @export
 * @interface NodeInfoDTO
 */
export interface NodeInfoDTO {
    /**
     * Version of the application.
     * @type {number}
     * @memberof NodeInfoDTO
     */
    'version': number;
    /**
     * Public key.
     * @type {string}
     * @memberof NodeInfoDTO
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof NodeInfoDTO
     */
    'networkGenerationHashSeed': string;
    /**
     * A number that defines the different roles the node provides. Possible roles are: * 1 - Peer node. * 2 - Api node. * 4 - Voting node. * 64 - IPv4 compatible node * 128 - IPv6 compatible node.  The values are bitwise added together, Examples: 1 = Just Peer. 2 = Just Api. 3 = Peer and Api node. 7 = Peer, Api and Voting node. 65 = IPv4 and Peer node. 
     * @type {number}
     * @memberof NodeInfoDTO
     */
    'roles': number;
    /**
     * Port used for the communication.
     * @type {number}
     * @memberof NodeInfoDTO
     */
    'port': number;
    /**
     * 
     * @type {number}
     * @memberof NodeInfoDTO
     */
    'networkIdentifier': number;
    /**
     * Node friendly name.
     * @type {string}
     * @memberof NodeInfoDTO
     */
    'friendlyName': string;
    /**
     * Node IP address.
     * @type {string}
     * @memberof NodeInfoDTO
     */
    'host': string;
    /**
     * Public key.
     * @type {string}
     * @memberof NodeInfoDTO
     */
    'nodePublicKey'?: string;
}
/**
 * 
 * @export
 * @interface NodeKeyLinkNetworkPropertiesDTO
 */
export interface NodeKeyLinkNetworkPropertiesDTO {
    /**
     * to trigger plugin load
     * @type {string}
     * @memberof NodeKeyLinkNetworkPropertiesDTO
     */
    'dummy'?: string;
}
/**
 * 
 * @export
 * @interface NodeKeyLinkTransactionBodyDTO
 */
export interface NodeKeyLinkTransactionBodyDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof NodeKeyLinkTransactionBodyDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof NodeKeyLinkTransactionBodyDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * Transaction to link a public key to an account. TLS uses the linked public key to create sessions. Required for node operators.  
 * @export
 * @interface NodeKeyLinkTransactionDTO
 */
export interface NodeKeyLinkTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'deadline': string;
    /**
     * Public key.
     * @type {string}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof NodeKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NodeStatusEnum = {
    Up: 'up',
    Down: 'down'
} as const;

export type NodeStatusEnum = typeof NodeStatusEnum[keyof typeof NodeStatusEnum];


/**
 * 
 * @export
 * @interface NodeTimeDTO
 */
export interface NodeTimeDTO {
    /**
     * 
     * @type {CommunicationTimestampsDTO}
     * @memberof NodeTimeDTO
     */
    'communicationTimestamps': CommunicationTimestampsDTO;
}
/**
 * Indicates how to sort the results:  * ``asc`` - ascending * ``desc`` - descending 
 * @export
 * @enum {string}
 */

export const Order = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type Order = typeof Order[keyof typeof Order];


/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageNumber': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageSize': number;
}
/**
 * 
 * @export
 * @interface ParentPublicKeySignaturePair
 */
export interface ParentPublicKeySignaturePair {
    /**
     * Public key.
     * @type {string}
     * @memberof ParentPublicKeySignaturePair
     */
    'parentPublicKey': string;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof ParentPublicKeySignaturePair
     */
    'signature': string;
}
/**
 * Plugin related configuration properties.
 * @export
 * @interface PluginsPropertiesDTO
 */
export interface PluginsPropertiesDTO {
    /**
     * 
     * @type {AccountKeyLinkNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'accountlink'?: AccountKeyLinkNetworkPropertiesDTO;
    /**
     * 
     * @type {AggregateNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'aggregate'?: AggregateNetworkPropertiesDTO;
    /**
     * 
     * @type {HashLockNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'lockhash'?: HashLockNetworkPropertiesDTO;
    /**
     * 
     * @type {SecretLockNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'locksecret'?: SecretLockNetworkPropertiesDTO;
    /**
     * 
     * @type {MetadataNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'metadata'?: MetadataNetworkPropertiesDTO;
    /**
     * 
     * @type {MosaicNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'mosaic'?: MosaicNetworkPropertiesDTO;
    /**
     * 
     * @type {MultisigNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'multisig'?: MultisigNetworkPropertiesDTO;
    /**
     * 
     * @type {NamespaceNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'namespace'?: NamespaceNetworkPropertiesDTO;
    /**
     * 
     * @type {AccountRestrictionNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'restrictionaccount'?: AccountRestrictionNetworkPropertiesDTO;
    /**
     * 
     * @type {MosaicRestrictionNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'restrictionmosaic'?: MosaicRestrictionNetworkPropertiesDTO;
    /**
     * 
     * @type {TransferNetworkPropertiesDTO}
     * @memberof PluginsPropertiesDTO
     */
    'transfer'?: TransferNetworkPropertiesDTO;
}
/**
 * Position relative to the proofHash being evaluated.
 * @export
 * @enum {string}
 */

export const PositionEnum = {
    Left: 'left',
    Right: 'right'
} as const;

export type PositionEnum = typeof PositionEnum[keyof typeof PositionEnum];


/**
 * 
 * @export
 * @interface ReceiptDTO
 */
export interface ReceiptDTO {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof ReceiptDTO
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof ReceiptDTO
     */
    'type': ReceiptTypeEnum;
}
/**
 * Type of receipt: * 0x124D (4685 decimal) - Mosaic_Rental_Fee. * 0x134E (4942 decimal) - Namespace_Rental_Fee. * 0x2143 (8515 decimal) - Harvest_Fee. * 0x2248 (8776 decimal) - LockHash_Completed. * 0x2348 (9032 decimal) - LockHash_Expired. * 0x2252 (8786 decimal) - LockSecret_Completed. * 0x2352 (9042 decimal) - LockSecret_Expired. * 0x3148 (12616 decimal) - LockHash_Created. * 0x3152 (12626 decimal) - LockSecret_Created. * 0x414D (16717 decimal) - Mosaic_Expired. * 0x414E (16718 decimal) - Namespace_Expired. * 0x424E (16974 decimal) - Namespace_Deleted. * 0x5143 (20803 decimal) - Inflation. * 0xE143 (57667 decimal) - Transaction_Group. * 0xF143 (61763 decimal) - Address_Alias_Resolution. * 0xF243 (62019 decimal) - Mosaic_Alias_Resolution. 
 * @export
 * @enum {string}
 */

export const ReceiptTypeEnum = {
    NUMBER_4685: 4685,
    NUMBER_4942: 4942,
    NUMBER_8515: 8515,
    NUMBER_8776: 8776,
    NUMBER_9032: 9032,
    NUMBER_8786: 8786,
    NUMBER_9042: 9042,
    NUMBER_12616: 12616,
    NUMBER_12626: 12626,
    NUMBER_16717: 16717,
    NUMBER_16718: 16718,
    NUMBER_16974: 16974,
    NUMBER_20803: 20803,
    NUMBER_57667: 57667,
    NUMBER_61763: 61763,
    NUMBER_62019: 62019
} as const;

export type ReceiptTypeEnum = typeof ReceiptTypeEnum[keyof typeof ReceiptTypeEnum];


/**
 * 
 * @export
 * @interface RentalFeesDTO
 */
export interface RentalFeesDTO {
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof RentalFeesDTO
     */
    'effectiveRootNamespaceRentalFeePerBlock': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof RentalFeesDTO
     */
    'effectiveChildNamespaceRentalFee': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof RentalFeesDTO
     */
    'effectiveMosaicRentalFee': string;
}
/**
 * 
 * @export
 * @interface ResolutionEntryDTO
 */
export interface ResolutionEntryDTO {
    /**
     * 
     * @type {SourceDTO}
     * @memberof ResolutionEntryDTO
     */
    'source': SourceDTO;
    /**
     * 
     * @type {ResolutionEntryDTOResolved}
     * @memberof ResolutionEntryDTO
     */
    'resolved': ResolutionEntryDTOResolved;
}
/**
 * 
 * @export
 * @interface ResolutionEntryDTOResolved
 */
export interface ResolutionEntryDTOResolved {
}
/**
 * 
 * @export
 * @interface ResolutionStatementDTO
 */
export interface ResolutionStatementDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof ResolutionStatementDTO
     */
    'height': string;
    /**
     * 
     * @type {ResolutionStatementDTOUnresolved}
     * @memberof ResolutionStatementDTO
     */
    'unresolved': ResolutionStatementDTOUnresolved;
    /**
     * Array of resolution entries linked to the unresolved namespaceId. It is an array instead of a single resolution entry since within one block the resolution might change for different sources due to alias related transactions. 
     * @type {Array<ResolutionEntryDTO>}
     * @memberof ResolutionStatementDTO
     */
    'resolutionEntries': Array<ResolutionEntryDTO>;
}
/**
 * 
 * @export
 * @interface ResolutionStatementDTOUnresolved
 */
export interface ResolutionStatementDTOUnresolved {
}
/**
 * A resolution statement keeps the relation between a namespace alias used in a transaction and the real address or mosaicId. 
 * @export
 * @interface ResolutionStatementInfoDTO
 */
export interface ResolutionStatementInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof ResolutionStatementInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {StatementMetaDTO}
     * @memberof ResolutionStatementInfoDTO
     */
    'meta': StatementMetaDTO;
    /**
     * 
     * @type {ResolutionStatementDTO}
     * @memberof ResolutionStatementInfoDTO
     */
    'statement': ResolutionStatementDTO;
}
/**
 * 
 * @export
 * @interface ResolutionStatementPage
 */
export interface ResolutionStatementPage {
    /**
     * Array of transaction address resolution statements.
     * @type {Array<ResolutionStatementInfoDTO>}
     * @memberof ResolutionStatementPage
     */
    'data': Array<ResolutionStatementInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof ResolutionStatementPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface SecretLockEntryDTO
 */
export interface SecretLockEntryDTO {
    /**
     * The version of the state
     * @type {number}
     * @memberof SecretLockEntryDTO
     */
    'version': number;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'ownerAddress': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'amount': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'endHeight': string;
    /**
     * 
     * @type {LockStatus}
     * @memberof SecretLockEntryDTO
     */
    'status': LockStatus;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof SecretLockEntryDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Secret.
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'secret': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof SecretLockEntryDTO
     */
    'compositeHash': string;
}
/**
 * 
 * @export
 * @interface SecretLockInfoDTO
 */
export interface SecretLockInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof SecretLockInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {SecretLockEntryDTO}
     * @memberof SecretLockInfoDTO
     */
    'lock': SecretLockEntryDTO;
}
/**
 * 
 * @export
 * @interface SecretLockNetworkPropertiesDTO
 */
export interface SecretLockNetworkPropertiesDTO {
    /**
     * Maximum number of blocks for which a secret lock can exist.
     * @type {string}
     * @memberof SecretLockNetworkPropertiesDTO
     */
    'maxSecretLockDuration'?: string;
    /**
     * Minimum size of a proof in bytes.
     * @type {string}
     * @memberof SecretLockNetworkPropertiesDTO
     */
    'minProofSize'?: string;
    /**
     * Maximum size of a proof in bytes.
     * @type {string}
     * @memberof SecretLockNetworkPropertiesDTO
     */
    'maxProofSize'?: string;
}
/**
 * 
 * @export
 * @interface SecretLockPage
 */
export interface SecretLockPage {
    /**
     * Array of secret locks.
     * @type {Array<SecretLockInfoDTO>}
     * @memberof SecretLockPage
     */
    'data': Array<SecretLockInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof SecretLockPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface SecretLockTransactionBodyDTO
 */
export interface SecretLockTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof SecretLockTransactionBodyDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof SecretLockTransactionBodyDTO
     */
    'secret': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof SecretLockTransactionBodyDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof SecretLockTransactionBodyDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof SecretLockTransactionBodyDTO
     */
    'duration': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof SecretLockTransactionBodyDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
}
/**
 * Transaction to sends mosaics to a recipient if the proof used is revealed. If the duration is reached, the locked funds go back to the sender of the transaction.
 * @export
 * @interface SecretLockTransactionDTO
 */
export interface SecretLockTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof SecretLockTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof SecretLockTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof SecretLockTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SecretLockTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'secret': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof SecretLockTransactionDTO
     */
    'duration': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof SecretLockTransactionDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
}
/**
 * 
 * @export
 * @interface SecretProofTransactionBodyDTO
 */
export interface SecretProofTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof SecretProofTransactionBodyDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof SecretProofTransactionBodyDTO
     */
    'secret': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof SecretProofTransactionBodyDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Original random set of bytes.
     * @type {string}
     * @memberof SecretProofTransactionBodyDTO
     */
    'proof': string;
}
/**
 * Transaction to reveal a proof.
 * @export
 * @interface SecretProofTransactionDTO
 */
export interface SecretProofTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof SecretProofTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof SecretProofTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof SecretProofTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SecretProofTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'secret': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof SecretProofTransactionDTO
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Original random set of bytes.
     * @type {string}
     * @memberof SecretProofTransactionDTO
     */
    'proof': string;
}
/**
 * 
 * @export
 * @interface ServerDTO
 */
export interface ServerDTO {
    /**
     * catapult-rest component version.
     * @type {string}
     * @memberof ServerDTO
     */
    'restVersion': string;
    /**
     * catapult-sdk component version.
     * @type {string}
     * @memberof ServerDTO
     */
    'sdkVersion': string;
    /**
     * 
     * @type {DeploymentDTO}
     * @memberof ServerDTO
     */
    'deployment': DeploymentDTO;
}
/**
 * 
 * @export
 * @interface ServerInfoDTO
 */
export interface ServerInfoDTO {
    /**
     * 
     * @type {ServerDTO}
     * @memberof ServerInfoDTO
     */
    'serverInfo': ServerDTO;
}
/**
 * 
 * @export
 * @interface SizePrefixedEntityDTO
 */
export interface SizePrefixedEntityDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof SizePrefixedEntityDTO
     */
    'size': number;
}
/**
 * Transaction that triggered the receipt.
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof SourceDTO
     */
    'primaryId': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof SourceDTO
     */
    'secondaryId': number;
}
/**
 * Type of stage: * 0 - Prevote. * 1 - Precommit. * 2 - Count. 
 * @export
 * @enum {string}
 */

export const StageEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type StageEnum = typeof StageEnum[keyof typeof StageEnum];


/**
 * Metadata related to the statment, including block information.
 * @export
 * @interface StatementMetaDTO
 */
export interface StatementMetaDTO {
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof StatementMetaDTO
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface StorageInfoDTO
 */
export interface StorageInfoDTO {
    /**
     * Number of blocks stored.
     * @type {number}
     * @memberof StorageInfoDTO
     */
    'numBlocks': number;
    /**
     * Number of transactions stored.
     * @type {number}
     * @memberof StorageInfoDTO
     */
    'numTransactions': number;
    /**
     * Number of accounts created.
     * @type {number}
     * @memberof StorageInfoDTO
     */
    'numAccounts': number;
}
/**
 * 
 * @export
 * @interface SupplementalPublicKeysDTO
 */
export interface SupplementalPublicKeysDTO {
    /**
     * 
     * @type {AccountLinkPublicKeyDTO}
     * @memberof SupplementalPublicKeysDTO
     */
    'linked'?: AccountLinkPublicKeyDTO;
    /**
     * 
     * @type {AccountLinkPublicKeyDTO}
     * @memberof SupplementalPublicKeysDTO
     */
    'node'?: AccountLinkPublicKeyDTO;
    /**
     * 
     * @type {AccountLinkPublicKeyDTO}
     * @memberof SupplementalPublicKeysDTO
     */
    'vrf'?: AccountLinkPublicKeyDTO;
    /**
     * 
     * @type {AccountLinkVotingKeysDTO}
     * @memberof SupplementalPublicKeysDTO
     */
    'voting'?: AccountLinkVotingKeysDTO;
}
/**
 * 
 * @export
 * @interface TransactionBodyDTO
 */
export interface TransactionBodyDTO {
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionBodyDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransactionBodyDTO
     */
    'deadline': string;
}
/**
 * 
 * @export
 * @interface TransactionDTO
 */
export interface TransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof TransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof TransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof TransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof TransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof TransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransactionDTO
     */
    'deadline': string;
}
/**
 * 
 * @export
 * @interface TransactionFeesDTO
 */
export interface TransactionFeesDTO {
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionFeesDTO
     */
    'averageFeeMultiplier': number;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionFeesDTO
     */
    'medianFeeMultiplier': number;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionFeesDTO
     */
    'highestFeeMultiplier': number;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionFeesDTO
     */
    'lowestFeeMultiplier': number;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionFeesDTO
     */
    'minFeeMultiplier': number;
}
/**
 * A transaction could be classified in the following groups: * Unconfirmed: The transaction reached the P2P network. At this point, it is not guaranteed that the transaction will be included in a block. * Confirmed: The transaction is included in a block. * Partial: The transaction requires to be cosigned by other transaction participants in order to be included in a block. * Failed: The transaction did not pass the network validation, and it was rejected. 
 * @export
 * @enum {string}
 */

export const TransactionGroupEnum = {
    Unconfirmed: 'unconfirmed',
    Confirmed: 'confirmed',
    Failed: 'failed',
    Partial: 'partial'
} as const;

export type TransactionGroupEnum = typeof TransactionGroupEnum[keyof typeof TransactionGroupEnum];


/**
 * 
 * @export
 * @interface TransactionHashes
 */
export interface TransactionHashes {
    /**
     * Array of transaction hashes.
     * @type {Array<string>}
     * @memberof TransactionHashes
     */
    'hashes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionIds
 */
export interface TransactionIds {
    /**
     * Array of transaction identifiers.
     * @type {Array<string>}
     * @memberof TransactionIds
     */
    'transactionIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionInfoDTO
 */
export interface TransactionInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof TransactionInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {TransactionInfoDTOMeta}
     * @memberof TransactionInfoDTO
     */
    'meta': TransactionInfoDTOMeta;
    /**
     * 
     * @type {TransactionInfoDTOTransaction}
     * @memberof TransactionInfoDTO
     */
    'transaction': TransactionInfoDTOTransaction;
}
/**
 * 
 * @export
 * @interface TransactionInfoDTOMeta
 */
export interface TransactionInfoDTOMeta {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'height': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'merkleComponentHash': string;
    /**
     * Transaction index within the aggregate.
     * @type {number}
     * @memberof TransactionInfoDTOMeta
     */
    'index': number;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'timestamp'?: string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionInfoDTOMeta
     */
    'feeMultiplier'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'aggregateHash': string;
    /**
     * Identifier of the aggregate transaction.
     * @type {string}
     * @memberof TransactionInfoDTOMeta
     */
    'aggregateId': string;
}
/**
 * 
 * @export
 * @interface TransactionInfoDTOTransaction
 */
export interface TransactionInfoDTOTransaction {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'deadline': string;
    /**
     * 32 bytes voting public key.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'linkAction': LinkActionEnum;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'endEpoch': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'transactionsHash': string;
    /**
     * Array of transaction cosignatures.
     * @type {Array<CosignatureDTO>}
     * @memberof TransactionInfoDTOTransaction
     */
    'cosignatures': Array<CosignatureDTO>;
    /**
     * Array of transactions initiated by different accounts.
     * @type {Array<EmbeddedTransactionInfoDTO>}
     * @memberof TransactionInfoDTOTransaction
     */
    'transactions': Array<EmbeddedTransactionInfoDTO>;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'amount': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'duration': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'hash': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'recipientAddress': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'secret': string;
    /**
     * 
     * @type {LockHashAlgorithmEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'hashAlgorithm': LockHashAlgorithmEnum;
    /**
     * Original random set of bytes.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'proof': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'targetAddress': string;
    /**
     * Metadata key scoped to source, target and type expressed.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'scopedMetadataKey': string;
    /**
     * Change in value size in bytes.
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'valueSizeDelta': number;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'valueSize': number;
    /**
     * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'value': string;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'targetMosaicId': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'targetNamespaceId'?: string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'id': string;
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'nonce': number;
    /**
     * - 0x00 (none) - No flags present. - 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply. - 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner. - 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner. - 0x08 (revokable) - Mosaic allows creator to revoke balances from another user. 
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'flags': number;
    /**
     * Determines up to what decimal place the mosaic can be divided. Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics. The divisibility must be in the range of 0 and 6. 
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'divisibility': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'delta': string;
    /**
     * 
     * @type {MosaicSupplyChangeActionEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'action': MosaicSupplyChangeActionEnum;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'sourceAddress': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'parentId'?: string;
    /**
     * 
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'registrationType': NamespaceRegistrationTypeEnum;
    /**
     * Namespace name.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'name': string;
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'namespaceId': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'address': string;
    /**
     * 
     * @type {AliasActionEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'aliasAction': AliasActionEnum;
    /**
     * Number of signatures needed to remove a cosignatory. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'minRemovalDelta': number;
    /**
     * Number of signatures needed to approve a transaction. If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories. 
     * @type {number}
     * @memberof TransactionInfoDTOTransaction
     */
    'minApprovalDelta': number;
    /**
     * Array of cosignatory accounts to add.
     * @type {Array<string>}
     * @memberof TransactionInfoDTOTransaction
     */
    'addressAdditions': Array<string>;
    /**
     * Array of cosignatory accounts to delete.
     * @type {Array<string>}
     * @memberof TransactionInfoDTOTransaction
     */
    'addressDeletions': Array<string>;
    /**
     * 
     * @type {AccountRestrictionFlagsEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'restrictionFlags': AccountRestrictionFlagsEnum;
    /**
     * Account restriction additions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof TransactionInfoDTOTransaction
     */
    'restrictionAdditions': Array<TransactionTypeEnum>;
    /**
     * Account restriction deletions.
     * @type {Array<TransactionTypeEnum>}
     * @memberof TransactionInfoDTOTransaction
     */
    'restrictionDeletions': Array<TransactionTypeEnum>;
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'referenceMosaicId': string;
    /**
     * Restriction key.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'restrictionKey': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'previousRestrictionValue': string;
    /**
     * Restriction value.
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'newRestrictionValue': string;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'previousRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * 
     * @type {MosaicRestrictionTypeEnum}
     * @memberof TransactionInfoDTOTransaction
     */
    'newRestrictionType': MosaicRestrictionTypeEnum;
    /**
     * Array of mosaics sent to the recipient. 
     * @type {Array<UnresolvedMosaic>}
     * @memberof TransactionInfoDTOTransaction
     */
    'mosaics': Array<UnresolvedMosaic>;
    /**
     * Transfer transaction message
     * @type {string}
     * @memberof TransactionInfoDTOTransaction
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TransactionMetaDTO
 */
export interface TransactionMetaDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof TransactionMetaDTO
     */
    'height': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionMetaDTO
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionMetaDTO
     */
    'merkleComponentHash': string;
    /**
     * Transaction index within the block.
     * @type {number}
     * @memberof TransactionMetaDTO
     */
    'index': number;
    /**
     * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network\'s \'epochAdjustment\'.
     * @type {string}
     * @memberof TransactionMetaDTO
     */
    'timestamp'?: string;
    /**
     * Fee multiplier applied to transactions contained in block.
     * @type {number}
     * @memberof TransactionMetaDTO
     */
    'feeMultiplier'?: number;
}
/**
 * 
 * @export
 * @interface TransactionPage
 */
export interface TransactionPage {
    /**
     * Array of transactions.
     * @type {Array<TransactionInfoDTO>}
     * @memberof TransactionPage
     */
    'data': Array<TransactionInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof TransactionPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface TransactionPayload
 */
export interface TransactionPayload {
    /**
     * Transaction payload in hexadecimal format.
     * @type {string}
     * @memberof TransactionPayload
     */
    'payload'?: string;
}
/**
 * 
 * @export
 * @interface TransactionStatementDTO
 */
export interface TransactionStatementDTO {
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof TransactionStatementDTO
     */
    'height': string;
    /**
     * 
     * @type {SourceDTO}
     * @memberof TransactionStatementDTO
     */
    'source': SourceDTO;
    /**
     * Array of receipts.
     * @type {Array<TransactionStatementDTOReceiptsInner>}
     * @memberof TransactionStatementDTO
     */
    'receipts': Array<TransactionStatementDTOReceiptsInner>;
}
/**
 * 
 * @export
 * @interface TransactionStatementDTOReceiptsInner
 */
export interface TransactionStatementDTOReceiptsInner {
    /**
     * Version of the receipt.
     * @type {number}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'version': number;
    /**
     * 
     * @type {ReceiptTypeEnum}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'type': ReceiptTypeEnum;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'mosaicId': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'amount': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'senderAddress': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'recipientAddress': string;
    /**
     * Address encoded using a 32-character set.
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'targetAddress': string;
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof TransactionStatementDTOReceiptsInner
     */
    'artifactId': string;
}
/**
 * Collection of receipts related to a transaction.
 * @export
 * @interface TransactionStatementInfoDTO
 */
export interface TransactionStatementInfoDTO {
    /**
     * Internal resource identifier.
     * @type {string}
     * @memberof TransactionStatementInfoDTO
     */
    'id': string;
    /**
     * 
     * @type {StatementMetaDTO}
     * @memberof TransactionStatementInfoDTO
     */
    'meta': StatementMetaDTO;
    /**
     * 
     * @type {TransactionStatementDTO}
     * @memberof TransactionStatementInfoDTO
     */
    'statement': TransactionStatementDTO;
}
/**
 * 
 * @export
 * @interface TransactionStatementPage
 */
export interface TransactionStatementPage {
    /**
     * Array of transaction statements.
     * @type {Array<TransactionStatementInfoDTO>}
     * @memberof TransactionStatementPage
     */
    'data': Array<TransactionStatementInfoDTO>;
    /**
     * 
     * @type {Pagination}
     * @memberof TransactionStatementPage
     */
    'pagination': Pagination;
}
/**
 * 
 * @export
 * @interface TransactionStatusDTO
 */
export interface TransactionStatusDTO {
    /**
     * 
     * @type {TransactionGroupEnum}
     * @memberof TransactionStatusDTO
     */
    'group': TransactionGroupEnum;
    /**
     * 
     * @type {TransactionStatusEnum}
     * @memberof TransactionStatusDTO
     */
    'code'?: TransactionStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionStatusDTO
     */
    'hash': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransactionStatusDTO
     */
    'deadline': string;
    /**
     * Height of the blockchain.
     * @type {string}
     * @memberof TransactionStatusDTO
     */
    'height'?: string;
}
/**
 * List of status errors that can be returned via the status channel after announcing a transaction: * Success * Neutral * Failure * Failure_Core_Past_Deadline - Validation failed because the deadline passed. * Failure_Core_Future_Deadline - Validation failed because the deadline is too far in the future. * Failure_Core_Insufficient_Balance - Validation failed because the account has an insufficient balance. * Failure_Core_Too_Many_Transactions - Validation failed because there are too many transactions in a block. * Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block - Validation failed because an entity originated from the nemesis account after the nemesis block. * Failure_Core_Wrong_Network - Validation failed because the entity has the wrong network specified. * Failure_Core_Invalid_Address - Validation failed because an address is invalid. * Failure_Core_Invalid_Version - Validation failed because entity version is invalid. * Failure_Core_Invalid_Transaction_Fee - Validation failed because a transaction fee is invalid. * Failure_Core_Block_Harvester_Ineligible - Validation failed because a block was harvested by an ineligible harvester. * Failure_Core_Zero_Address - Validation failed because an address is zero. * Failure_Core_Zero_Public_Key - Validation failed because a public key is zero. * Failure_Core_Nonzero_Internal_Padding - Validation failed because internal padding is nonzero. * Failure_Core_Address_Collision - Validation failed because an address collision is detected. * Failure_Core_Importance_Block_Mismatch - Validation failed because the block does not match the schema of an importance block. * Failure_Core_Unexpected_Block_Type - Validation failed because the block type is unexpected. * Failure_Core_Block_Explicit_Transactions_Hash_Mismatch - Validation failed because a block did not have the expected transactions hash at a specified height. * Failure_Core_Invalid_Link_Action - Validation failed because link action is invalid. * Failure_Core_Link_Already_Exists - Validation failed because main account is already linked to another account. * Failure_Core_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link. * Failure_Core_Invalid_Link_Range - Validation failed because link range is invalid. * Failure_Core_Too_Many_Links - Validation failed because main account has too many links of the specified type. * Failure_Core_Link_Start_Epoch_Invalid - Validation failed because the start epoch is invalid. * Failure_Hash_Already_Exists * Failure_Signature_Not_Verifiable - Validation failed because the verification of the signature failed. * Failure_AccountLink_Link_Already_Exists - Validation failed because main account is already linked to another account. * Failure_AccountLink_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link. * Failure_AccountLink_Unknown_Link - Validation failed because main account is not linked to another account. * Failure_AccountLink_Remote_Account_Ineligible - Validation failed because link is attempting to convert ineligible account to remote. * Failure_AccountLink_Remote_Account_Signer_Prohibited - Validation failed because remote is not allowed to sign a transaction. * Failure_AccountLink_Remote_Account_Participant_Prohibited - Validation failed because remote is not allowed to participate in the transaction. * Failure_Aggregate_Too_Many_Transactions - Validation failed because aggregate has too many transactions. * Failure_Aggregate_No_Transactions - Validation failed because aggregate does not have any transactions. * Failure_Aggregate_Too_Many_Cosignatures - Validation failed because aggregate has too many cosignatures. * Failure_Aggregate_Redundant_Cosignatures - Validation failed because redundant cosignatures are present. * Failure_Aggregate_Ineligible_Cosignatories - Validation failed because at least one cosignatory is ineligible. * Failure_Aggregate_Missing_Cosignatures - Validation failed because at least one required cosignature is missing. * Failure_Aggregate_Transactions_Hash_Mismatch - Validation failed because the aggregate transactions hash does not match the calculated value. * Failure_LockHash_Invalid_Mosaic_Id - Validation failed because lock does not allow the specified mosaic. * Failure_LockHash_Invalid_Mosaic_Amount - Validation failed because lock does not allow the specified amount. * Failure_LockHash_Hash_Already_Exists - Validation failed because hash is already present in cache. * Failure_LockHash_Unknown_Hash - Validation failed because hash is not present in cache. * Failure_LockHash_Inactive_Hash - Validation failed because hash is inactive. * Failure_LockHash_Invalid_Duration - Validation failed because duration is too long. * Failure_LockSecret_Invalid_Hash_Algorithm - Validation failed because hash algorithm for lock type secret is invalid. * Failure_LockSecret_Hash_Already_Exists - Validation failed because hash is already present in cache. * Failure_LockSecret_Proof_Size_Out_Of_Bounds - Validation failed because proof is too small or too large. * Failure_LockSecret_Secret_Mismatch - Validation failed because secret does not match proof. * Failure_LockSecret_Unknown_Composite_Key - Validation failed because composite key is unknown. * Failure_LockSecret_Inactive_Secret - Validation failed because secret is inactive. * Failure_LockSecret_Hash_Algorithm_Mismatch - Validation failed because hash algorithm does not match. * Failure_LockSecret_Invalid_Duration - Validation failed because duration is too long. * Failure_Metadata_Value_Too_Small - Validation failed because the metadata value is too small. * Failure_Metadata_Value_Too_Large - Validation failed because the metadata value is too large. * Failure_Metadata_Value_Size_Delta_Too_Large - Validation failed because the metadata value size delta is larger in magnitude than the value size. * Failure_Metadata_Value_Size_Delta_Mismatch - Validation failed because the metadata value size delta does not match expected value based on the current state. * Failure_Metadata_Value_Change_Irreversible - Validation failed because a metadata value change (truncation) is irreversible. * Failure_Mosaic_Invalid_Duration - Validation failed because the duration has an invalid value. * Failure_Mosaic_Invalid_Name - Validation failed because the name is invalid. * Failure_Mosaic_Name_Id_Mismatch - Validation failed because the name and id don\'t match. * Failure_Mosaic_Expired - Validation failed because the parent is expired. * Failure_Mosaic_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner. * Failure_Mosaic_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce. * Failure_Mosaic_Parent_Id_Conflict - Validation failed because the existing parent id does not match the supplied parent id. * Failure_Mosaic_Invalid_Property - Validation failed because a mosaic property is invalid. * Failure_Mosaic_Invalid_Flags - Validation failed because the mosaic flags are invalid. * Failure_Mosaic_Invalid_Divisibility - Validation failed because the mosaic divisibility is invalid. * Failure_Mosaic_Invalid_Supply_Change_Action - Validation failed because the mosaic supply change action is invalid. * Failure_Mosaic_Invalid_Supply_Change_Amount - Validation failed because the mosaic supply change amount is invalid. * Failure_Mosaic_Invalid_Id - Validation failed because the mosaic id is invalid. * Failure_Mosaic_Modification_Disallowed - Validation failed because mosaic modification is not allowed. * Failure_Mosaic_Modification_No_Changes - Validation failed because mosaic modification would not result in any changes. * Failure_Mosaic_Supply_Immutable - Validation failed because the mosaic supply is immutable. * Failure_Mosaic_Supply_Negative - Validation failed because the resulting mosaic supply is negative. * Failure_Mosaic_Supply_Exceeded - Validation failed because the resulting mosaic supply exceeds the maximum allowed value. * Failure_Mosaic_Non_Transferable - Validation failed because the mosaic is not transferable. * Failure_Mosaic_Max_Mosaics_Exceeded - Validation failed because the credit of the mosaic would exceed the maximum of different mosaics an account is allowed to own. * Failure_Mosaic_Required_Property_Flag_Unset - Validation failed because the mosaic has at least one required property flag unset. * Failure_Multisig_Account_In_Both_Sets - Validation failed because account is specified to be both added and removed. * Failure_Multisig_Multiple_Deletes - Validation failed because multiple removals are present. * Failure_Multisig_Redundant_Modification - Validation failed because a modification is redundant. * Failure_Multisig_Unknown_Multisig_Account - Validation failed because account is not in multisig cache. * Failure_Multisig_Not_A_Cosignatory - Validation failed because account to be removed is not present. * Failure_Multisig_Already_A_Cosignatory - Validation failed because account to be added is already a cosignatory. * Failure_Multisig_Min_Setting_Out_Of_Range - Validation failed because new minimum settings are out of range. * Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories - Validation failed because min settings are larger than number of cosignatories. * Failure_Multisig_Invalid_Modification_Action - Validation failed because the modification action is invalid. * Failure_Multisig_Max_Cosigned_Accounts - Validation failed because the cosignatory already cosigns the maximum number of accounts. * Failure_Multisig_Max_Cosignatories - Validation failed because the multisig account already has the maximum number of cosignatories. * Failure_Multisig_Loop - Validation failed because a multisig loop is created. * Failure_Multisig_Max_Multisig_Depth - Validation failed because the max multisig depth is exceeded. * Failure_Multisig_Operation_Prohibited_By_Account - Validation failed because an operation is not permitted by a multisig account. * Failure_Namespace_Invalid_Duration - Validation failed because the duration has an invalid value. * Failure_Namespace_Invalid_Name - Validation failed because the name is invalid. * Failure_Namespace_Name_Id_Mismatch - Validation failed because the name and id don\'t match. * Failure_Namespace_Expired - Validation failed because the parent is expired. * Failure_Namespace_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner. * Failure_Namespace_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce. * Failure_Namespace_Invalid_Registration_Type - Validation failed because the namespace registration type is invalid. * Failure_Namespace_Root_Name_Reserved - Validation failed because the root namespace has a reserved name. * Failure_Namespace_Too_Deep - Validation failed because the resulting namespace would exceed the maximum allowed namespace depth. * Failure_Namespace_Unknown_Parent - Validation failed because the namespace parent is unknown. * Failure_Namespace_Already_Exists - Validation failed because the namespace already exists. * Failure_Namespace_Already_Active - Validation failed because the namespace is already active. * Failure_Namespace_Eternal_After_Nemesis_Block - Validation failed because an eternal namespace was received after the nemesis block. * Failure_Namespace_Max_Children_Exceeded - Validation failed because the maximum number of children for a root namespace was exceeded. * Failure_Namespace_Alias_Invalid_Action - Validation failed because alias action is invalid. * Failure_Namespace_Unknown - Validation failed because namespace does not exist. * Failure_Namespace_Alias_Already_Exists - Validation failed because namespace is already linked to an alias. * Failure_Namespace_Unknown_Alias - Validation failed because namespace is not linked to an alias. * Failure_Namespace_Alias_Inconsistent_Unlink_Type - Validation failed because unlink type is not consistent with existing alias. * Failure_Namespace_Alias_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing alias. * Failure_Namespace_Alias_Invalid_Address - Validation failed because aliased address is invalid. * Failure_RestrictionAccount_Invalid_Restriction_Flags - Validation failed because the account restriction flags are invalid. * Failure_RestrictionAccount_Invalid_Modification_Action - Validation failed because a modification action is invalid. * Failure_RestrictionAccount_Invalid_Modification_Address - Validation failed because a modification address is invalid. * Failure_RestrictionAccount_Modification_Operation_Type_Incompatible - Validation failed because the operation type is incompatible. *Note*: This indicates that the existing restrictions have a different operation type than that specified in the notification. * Failure_RestrictionAccount_Redundant_Modification - Validation failed because a modification is redundant. * Failure_RestrictionAccount_Invalid_Modification - Validation failed because a value is not in the container. * Failure_RestrictionAccount_Modification_Count_Exceeded - Validation failed because the transaction has too many modifications. * Failure_RestrictionAccount_No_Modifications - Validation failed because the transaction has no modifications. * Failure_RestrictionAccount_Values_Count_Exceeded - Validation failed because the resulting account restriction has too many values. * Failure_RestrictionAccount_Invalid_Value - Validation failed because the account restriction value is invalid. * Failure_RestrictionAccount_Address_Interaction_Prohibited - Validation failed because the addresses involved in the transaction are not allowed to interact. * Failure_RestrictionAccount_Mosaic_Transfer_Prohibited - Validation failed because the mosaic transfer is prohibited by the recipient. * Failure_RestrictionAccount_Operation_Type_Prohibited - Validation failed because the operation type is not allowed to be initiated by the signer. * Failure_RestrictionMosaic_Invalid_Restriction_Type - Validation failed because the mosaic restriction type is invalid. * Failure_RestrictionMosaic_Previous_Value_Mismatch - Validation failed because specified previous value does not match current value. * Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero - Validation failed because specified previous value is nonzero. * Failure_RestrictionMosaic_Max_Restrictions_Exceeded - Validation failed because the maximum number of restrictions would be exceeded. * Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction - Validation failed because nonexistent restriction cannot be deleted. * Failure_RestrictionMosaic_Unknown_Global_Restriction - Validation failed because required global restriction does not exist. * Failure_RestrictionMosaic_Invalid_Global_Restriction - Validation failed because mosaic has invalid global restriction. * Failure_RestrictionMosaic_Account_Unauthorized - Validation failed because account lacks proper permissions to move mosaic. * Failure_Transfer_Message_Too_Large - Validation failed because the message is too large. * Failure_Transfer_Out_Of_Order_Mosaics - Validation failed because mosaics are out of order. * Failure_Chain_Unlinked - Validation failed because a block was received that did not link with the existing chain. * Failure_Chain_Block_Not_Hit - Validation failed because a block was received that is not a hit. * Failure_Chain_Block_Inconsistent_State_Hash - Validation failed because a block was received that has an inconsistent state hash. * Failure_Chain_Block_Inconsistent_Receipts_Hash - Validation failed because a block was received that has an inconsistent receipts hash. * Failure_Chain_Block_Invalid_Vrf_Proof - Validation failed because the Vrf proof is invalid. * Failure_Chain_Block_Unknown_Signer - Validation failed because the block signer is unknown. * Failure_Chain_Unconfirmed_Cache_Too_Full - Validation failed because the unconfirmed cache is too full. * Failure_Consumer_Empty_Input - Validation failed because the consumer input is empty. * Failure_Consumer_Block_Transactions_Hash_Mismatch - Validation failed because the block transactions hash does not match the calculated value. * Neutral_Consumer_Hash_In_Recency_Cache - Validation failed because an entity hash is present in the recency cache. * Failure_Consumer_Remote_Chain_Too_Many_Blocks - Validation failed because the chain part has too many blocks. * Failure_Consumer_Remote_Chain_Improper_Link - Validation failed because the chain is internally improperly linked. * Failure_Consumer_Remote_Chain_Duplicate_Transactions - Validation failed because the chain part contains duplicate transactions. * Failure_Consumer_Remote_Chain_Unlinked - Validation failed because the chain part does not link to the current chain. * Failure_Consumer_Remote_Chain_Difficulties_Mismatch - Validation failed because the remote chain difficulties do not match the calculated difficulties. * Failure_Consumer_Remote_Chain_Score_Not_Better - Validation failed because the remote chain score is not better. * Failure_Consumer_Remote_Chain_Too_Far_Behind - Validation failed because the remote chain is too far behind. * Failure_Consumer_Remote_Chain_Too_Far_In_Future - Validation failed because the remote chain timestamp is too far in the future. * Failure_Consumer_Batch_Signature_Not_Verifiable - Validation failed because the verification of the signature failed during a batch operation. * Failure_Consumer_Remote_Chain_Improper_Importance_Link - Validation failed because the remote chain has an improper importance link. * Failure_Extension_Partial_Transaction_Cache_Prune - Validation failed because the partial transaction was pruned from the temporal cache. * Failure_Extension_Partial_Transaction_Dependency_Removed - Validation failed because the partial transaction was pruned from the temporal cache due to its dependency being removed. * Failure_Extension_Read_Rate_Limit_Exceeded - Validation failed because socket read rate limit was exceeded. 
 * @export
 * @enum {string}
 */

export const TransactionStatusEnum = {
    Success: 'Success',
    Neutral: 'Neutral',
    Failure: 'Failure',
    FailureCorePastDeadline: 'Failure_Core_Past_Deadline',
    FailureCoreFutureDeadline: 'Failure_Core_Future_Deadline',
    FailureCoreInsufficientBalance: 'Failure_Core_Insufficient_Balance',
    FailureCoreTooManyTransactions: 'Failure_Core_Too_Many_Transactions',
    FailureCoreNemesisAccountSignedAfterNemesisBlock: 'Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block',
    FailureCoreWrongNetwork: 'Failure_Core_Wrong_Network',
    FailureCoreInvalidAddress: 'Failure_Core_Invalid_Address',
    FailureCoreInvalidVersion: 'Failure_Core_Invalid_Version',
    FailureCoreInvalidTransactionFee: 'Failure_Core_Invalid_Transaction_Fee',
    FailureCoreBlockHarvesterIneligible: 'Failure_Core_Block_Harvester_Ineligible',
    FailureCoreZeroAddress: 'Failure_Core_Zero_Address',
    FailureCoreZeroPublicKey: 'Failure_Core_Zero_Public_Key',
    FailureCoreNonzeroInternalPadding: 'Failure_Core_Nonzero_Internal_Padding',
    FailureCoreAddressCollision: 'Failure_Core_Address_Collision',
    FailureCoreImportanceBlockMismatch: 'Failure_Core_Importance_Block_Mismatch',
    FailureCoreUnexpectedBlockType: 'Failure_Core_Unexpected_Block_Type',
    FailureCoreBlockExplicitTransactionsHashMismatch: 'Failure_Core_Block_Explicit_Transactions_Hash_Mismatch',
    FailureCoreInvalidLinkAction: 'Failure_Core_Invalid_Link_Action',
    FailureCoreLinkAlreadyExists: 'Failure_Core_Link_Already_Exists',
    FailureCoreInconsistentUnlinkData: 'Failure_Core_Inconsistent_Unlink_Data',
    FailureCoreInvalidLinkRange: 'Failure_Core_Invalid_Link_Range',
    FailureCoreTooManyLinks: 'Failure_Core_Too_Many_Links',
    FailureCoreLinkStartEpochInvalid: 'Failure_Core_Link_Start_Epoch_Invalid',
    FailureHashAlreadyExists: 'Failure_Hash_Already_Exists',
    FailureSignatureNotVerifiable: 'Failure_Signature_Not_Verifiable',
    FailureAccountLinkLinkAlreadyExists: 'Failure_AccountLink_Link_Already_Exists',
    FailureAccountLinkInconsistentUnlinkData: 'Failure_AccountLink_Inconsistent_Unlink_Data',
    FailureAccountLinkUnknownLink: 'Failure_AccountLink_Unknown_Link',
    FailureAccountLinkRemoteAccountIneligible: 'Failure_AccountLink_Remote_Account_Ineligible',
    FailureAccountLinkRemoteAccountSignerProhibited: 'Failure_AccountLink_Remote_Account_Signer_Prohibited',
    FailureAccountLinkRemoteAccountParticipantProhibited: 'Failure_AccountLink_Remote_Account_Participant_Prohibited',
    FailureAggregateTooManyTransactions: 'Failure_Aggregate_Too_Many_Transactions',
    FailureAggregateNoTransactions: 'Failure_Aggregate_No_Transactions',
    FailureAggregateTooManyCosignatures: 'Failure_Aggregate_Too_Many_Cosignatures',
    FailureAggregateRedundantCosignatures: 'Failure_Aggregate_Redundant_Cosignatures',
    FailureAggregateIneligibleCosignatories: 'Failure_Aggregate_Ineligible_Cosignatories',
    FailureAggregateMissingCosignatures: 'Failure_Aggregate_Missing_Cosignatures',
    FailureAggregateTransactionsHashMismatch: 'Failure_Aggregate_Transactions_Hash_Mismatch',
    FailureLockHashInvalidMosaicId: 'Failure_LockHash_Invalid_Mosaic_Id',
    FailureLockHashInvalidMosaicAmount: 'Failure_LockHash_Invalid_Mosaic_Amount',
    FailureLockHashHashAlreadyExists: 'Failure_LockHash_Hash_Already_Exists',
    FailureLockHashUnknownHash: 'Failure_LockHash_Unknown_Hash',
    FailureLockHashInactiveHash: 'Failure_LockHash_Inactive_Hash',
    FailureLockHashInvalidDuration: 'Failure_LockHash_Invalid_Duration',
    FailureLockSecretInvalidHashAlgorithm: 'Failure_LockSecret_Invalid_Hash_Algorithm',
    FailureLockSecretHashAlreadyExists: 'Failure_LockSecret_Hash_Already_Exists',
    FailureLockSecretProofSizeOutOfBounds: 'Failure_LockSecret_Proof_Size_Out_Of_Bounds',
    FailureLockSecretSecretMismatch: 'Failure_LockSecret_Secret_Mismatch',
    FailureLockSecretUnknownCompositeKey: 'Failure_LockSecret_Unknown_Composite_Key',
    FailureLockSecretInactiveSecret: 'Failure_LockSecret_Inactive_Secret',
    FailureLockSecretHashAlgorithmMismatch: 'Failure_LockSecret_Hash_Algorithm_Mismatch',
    FailureLockSecretInvalidDuration: 'Failure_LockSecret_Invalid_Duration',
    FailureMetadataValueTooSmall: 'Failure_Metadata_Value_Too_Small',
    FailureMetadataValueTooLarge: 'Failure_Metadata_Value_Too_Large',
    FailureMetadataValueSizeDeltaTooLarge: 'Failure_Metadata_Value_Size_Delta_Too_Large',
    FailureMetadataValueSizeDeltaMismatch: 'Failure_Metadata_Value_Size_Delta_Mismatch',
    FailureMetadataValueChangeIrreversible: 'Failure_Metadata_Value_Change_Irreversible',
    FailureMosaicInvalidDuration: 'Failure_Mosaic_Invalid_Duration',
    FailureMosaicInvalidName: 'Failure_Mosaic_Invalid_Name',
    FailureMosaicNameIdMismatch: 'Failure_Mosaic_Name_Id_Mismatch',
    FailureMosaicExpired: 'Failure_Mosaic_Expired',
    FailureMosaicOwnerConflict: 'Failure_Mosaic_Owner_Conflict',
    FailureMosaicIdMismatch: 'Failure_Mosaic_Id_Mismatch',
    FailureMosaicParentIdConflict: 'Failure_Mosaic_Parent_Id_Conflict',
    FailureMosaicInvalidProperty: 'Failure_Mosaic_Invalid_Property',
    FailureMosaicInvalidFlags: 'Failure_Mosaic_Invalid_Flags',
    FailureMosaicInvalidDivisibility: 'Failure_Mosaic_Invalid_Divisibility',
    FailureMosaicInvalidSupplyChangeAction: 'Failure_Mosaic_Invalid_Supply_Change_Action',
    FailureMosaicInvalidSupplyChangeAmount: 'Failure_Mosaic_Invalid_Supply_Change_Amount',
    FailureMosaicInvalidId: 'Failure_Mosaic_Invalid_Id',
    FailureMosaicModificationDisallowed: 'Failure_Mosaic_Modification_Disallowed',
    FailureMosaicModificationNoChanges: 'Failure_Mosaic_Modification_No_Changes',
    FailureMosaicSupplyImmutable: 'Failure_Mosaic_Supply_Immutable',
    FailureMosaicSupplyNegative: 'Failure_Mosaic_Supply_Negative',
    FailureMosaicSupplyExceeded: 'Failure_Mosaic_Supply_Exceeded',
    FailureMosaicNonTransferable: 'Failure_Mosaic_Non_Transferable',
    FailureMosaicMaxMosaicsExceeded: 'Failure_Mosaic_Max_Mosaics_Exceeded',
    FailureMosaicRequiredPropertyFlagUnset: 'Failure_Mosaic_Required_Property_Flag_Unset',
    FailureMultisigAccountInBothSets: 'Failure_Multisig_Account_In_Both_Sets',
    FailureMultisigMultipleDeletes: 'Failure_Multisig_Multiple_Deletes',
    FailureMultisigRedundantModification: 'Failure_Multisig_Redundant_Modification',
    FailureMultisigUnknownMultisigAccount: 'Failure_Multisig_Unknown_Multisig_Account',
    FailureMultisigNotACosignatory: 'Failure_Multisig_Not_A_Cosignatory',
    FailureMultisigAlreadyACosignatory: 'Failure_Multisig_Already_A_Cosignatory',
    FailureMultisigMinSettingOutOfRange: 'Failure_Multisig_Min_Setting_Out_Of_Range',
    FailureMultisigMinSettingLargerThanNumCosignatories: 'Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories',
    FailureMultisigInvalidModificationAction: 'Failure_Multisig_Invalid_Modification_Action',
    FailureMultisigMaxCosignedAccounts: 'Failure_Multisig_Max_Cosigned_Accounts',
    FailureMultisigMaxCosignatories: 'Failure_Multisig_Max_Cosignatories',
    FailureMultisigLoop: 'Failure_Multisig_Loop',
    FailureMultisigMaxMultisigDepth: 'Failure_Multisig_Max_Multisig_Depth',
    FailureMultisigOperationProhibitedByAccount: 'Failure_Multisig_Operation_Prohibited_By_Account',
    FailureNamespaceInvalidDuration: 'Failure_Namespace_Invalid_Duration',
    FailureNamespaceInvalidName: 'Failure_Namespace_Invalid_Name',
    FailureNamespaceNameIdMismatch: 'Failure_Namespace_Name_Id_Mismatch',
    FailureNamespaceExpired: 'Failure_Namespace_Expired',
    FailureNamespaceOwnerConflict: 'Failure_Namespace_Owner_Conflict',
    FailureNamespaceIdMismatch: 'Failure_Namespace_Id_Mismatch',
    FailureNamespaceInvalidRegistrationType: 'Failure_Namespace_Invalid_Registration_Type',
    FailureNamespaceRootNameReserved: 'Failure_Namespace_Root_Name_Reserved',
    FailureNamespaceTooDeep: 'Failure_Namespace_Too_Deep',
    FailureNamespaceUnknownParent: 'Failure_Namespace_Unknown_Parent',
    FailureNamespaceAlreadyExists: 'Failure_Namespace_Already_Exists',
    FailureNamespaceAlreadyActive: 'Failure_Namespace_Already_Active',
    FailureNamespaceEternalAfterNemesisBlock: 'Failure_Namespace_Eternal_After_Nemesis_Block',
    FailureNamespaceMaxChildrenExceeded: 'Failure_Namespace_Max_Children_Exceeded',
    FailureNamespaceAliasInvalidAction: 'Failure_Namespace_Alias_Invalid_Action',
    FailureNamespaceUnknown: 'Failure_Namespace_Unknown',
    FailureNamespaceAliasAlreadyExists: 'Failure_Namespace_Alias_Already_Exists',
    FailureNamespaceUnknownAlias: 'Failure_Namespace_Unknown_Alias',
    FailureNamespaceAliasInconsistentUnlinkType: 'Failure_Namespace_Alias_Inconsistent_Unlink_Type',
    FailureNamespaceAliasInconsistentUnlinkData: 'Failure_Namespace_Alias_Inconsistent_Unlink_Data',
    FailureNamespaceAliasInvalidAddress: 'Failure_Namespace_Alias_Invalid_Address',
    FailureRestrictionAccountInvalidRestrictionFlags: 'Failure_RestrictionAccount_Invalid_Restriction_Flags',
    FailureRestrictionAccountInvalidModificationAction: 'Failure_RestrictionAccount_Invalid_Modification_Action',
    FailureRestrictionAccountInvalidModificationAddress: 'Failure_RestrictionAccount_Invalid_Modification_Address',
    FailureRestrictionAccountModificationOperationTypeIncompatible: 'Failure_RestrictionAccount_Modification_Operation_Type_Incompatible',
    FailureRestrictionAccountRedundantModification: 'Failure_RestrictionAccount_Redundant_Modification',
    FailureRestrictionAccountInvalidModification: 'Failure_RestrictionAccount_Invalid_Modification',
    FailureRestrictionAccountModificationCountExceeded: 'Failure_RestrictionAccount_Modification_Count_Exceeded',
    FailureRestrictionAccountNoModifications: 'Failure_RestrictionAccount_No_Modifications',
    FailureRestrictionAccountValuesCountExceeded: 'Failure_RestrictionAccount_Values_Count_Exceeded',
    FailureRestrictionAccountInvalidValue: 'Failure_RestrictionAccount_Invalid_Value',
    FailureRestrictionAccountAddressInteractionProhibited: 'Failure_RestrictionAccount_Address_Interaction_Prohibited',
    FailureRestrictionAccountMosaicTransferProhibited: 'Failure_RestrictionAccount_Mosaic_Transfer_Prohibited',
    FailureRestrictionAccountOperationTypeProhibited: 'Failure_RestrictionAccount_Operation_Type_Prohibited',
    FailureRestrictionMosaicInvalidRestrictionType: 'Failure_RestrictionMosaic_Invalid_Restriction_Type',
    FailureRestrictionMosaicPreviousValueMismatch: 'Failure_RestrictionMosaic_Previous_Value_Mismatch',
    FailureRestrictionMosaicPreviousValueMustBeZero: 'Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero',
    FailureRestrictionMosaicMaxRestrictionsExceeded: 'Failure_RestrictionMosaic_Max_Restrictions_Exceeded',
    FailureRestrictionMosaicCannotDeleteNonexistentRestriction: 'Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction',
    FailureRestrictionMosaicUnknownGlobalRestriction: 'Failure_RestrictionMosaic_Unknown_Global_Restriction',
    FailureRestrictionMosaicInvalidGlobalRestriction: 'Failure_RestrictionMosaic_Invalid_Global_Restriction',
    FailureRestrictionMosaicAccountUnauthorized: 'Failure_RestrictionMosaic_Account_Unauthorized',
    FailureTransferMessageTooLarge: 'Failure_Transfer_Message_Too_Large',
    FailureTransferOutOfOrderMosaics: 'Failure_Transfer_Out_Of_Order_Mosaics',
    FailureChainUnlinked: 'Failure_Chain_Unlinked',
    FailureChainBlockNotHit: 'Failure_Chain_Block_Not_Hit',
    FailureChainBlockInconsistentStateHash: 'Failure_Chain_Block_Inconsistent_State_Hash',
    FailureChainBlockInconsistentReceiptsHash: 'Failure_Chain_Block_Inconsistent_Receipts_Hash',
    FailureChainBlockInvalidVrfProof: 'Failure_Chain_Block_Invalid_Vrf_Proof',
    FailureChainBlockUnknownSigner: 'Failure_Chain_Block_Unknown_Signer',
    FailureChainUnconfirmedCacheTooFull: 'Failure_Chain_Unconfirmed_Cache_Too_Full',
    FailureConsumerEmptyInput: 'Failure_Consumer_Empty_Input',
    FailureConsumerBlockTransactionsHashMismatch: 'Failure_Consumer_Block_Transactions_Hash_Mismatch',
    NeutralConsumerHashInRecencyCache: 'Neutral_Consumer_Hash_In_Recency_Cache',
    FailureConsumerRemoteChainTooManyBlocks: 'Failure_Consumer_Remote_Chain_Too_Many_Blocks',
    FailureConsumerRemoteChainImproperLink: 'Failure_Consumer_Remote_Chain_Improper_Link',
    FailureConsumerRemoteChainDuplicateTransactions: 'Failure_Consumer_Remote_Chain_Duplicate_Transactions',
    FailureConsumerRemoteChainUnlinked: 'Failure_Consumer_Remote_Chain_Unlinked',
    FailureConsumerRemoteChainDifficultiesMismatch: 'Failure_Consumer_Remote_Chain_Difficulties_Mismatch',
    FailureConsumerRemoteChainScoreNotBetter: 'Failure_Consumer_Remote_Chain_Score_Not_Better',
    FailureConsumerRemoteChainTooFarBehind: 'Failure_Consumer_Remote_Chain_Too_Far_Behind',
    FailureConsumerRemoteChainTooFarInFuture: 'Failure_Consumer_Remote_Chain_Too_Far_In_Future',
    FailureConsumerBatchSignatureNotVerifiable: 'Failure_Consumer_Batch_Signature_Not_Verifiable',
    FailureConsumerRemoteChainImproperImportanceLink: 'Failure_Consumer_Remote_Chain_Improper_Importance_Link',
    FailureExtensionPartialTransactionCachePrune: 'Failure_Extension_Partial_Transaction_Cache_Prune',
    FailureExtensionPartialTransactionDependencyRemoved: 'Failure_Extension_Partial_Transaction_Dependency_Removed',
    FailureExtensionReadRateLimitExceeded: 'Failure_Extension_Read_Rate_Limit_Exceeded'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];


/**
 * Type of transaction: * 0x414C (16716 decimal) - AccountKeyLinkTransaction. * 0x4243 (16963 decimal) - VrfKeyLinkTransaction. * 0x4143 (16707 decimal) - VotingKeyLinkTransaction. * 0x424C (16972 decimal) - NodeKeyLinkTransaction. * 0x4141 (16705 decimal) - AggregateCompleteTransaction. * 0x4241 (16961 decimal) - AggregateBondedTransaction. * 0x414D (16717 decimal) - MosaicDefinitionTransaction. * 0x424D (16973 decimal) - MosaicSupplyChangeTransaction. * 0x434D (17229 decimal) - MosaicSupplyRevocationTransaction. * 0x414E (16718 decimal) - NamespaceRegistrationTransaction. * 0x424E (16974 decimal) - AddressAliasTransaction. * 0x434E (17230 decimal) - MosaicAliasTransaction. * 0x4144 (16708 decimal) - AccountMetadataTransaction. * 0x4244 (16964 decimal) - MosaicMetadataTransaction. * 0x4344 (17220 decimal) - NamespaceMetadataTransaction. * 0x4155 (16725 decimal) - MultisigAccountModificationTransaction. * 0x4148 (16712 decimal) - HashLockTransaction. * 0x4152 (16722 decimal) - SecretLockTransaction. * 0x4252 (16978 decimal) - SecretProofTransaction. * 0x4150 (16720 decimal) - AccountAddressRestrictionTransaction. * 0x4250 (16976 decimal) - AccountMosaicRestrictionTransaction. * 0x4350 (17232 decimal) - AccountOperationRestrictionTransaction. * 0x4151 (16721 decimal) - MosaicGlobalRestrictionTransaction. * 0x4251 (16977 decimal) - MosaicAddressRestrictionTransaction. * 0x4154 (16724 decimal) - TransferTransaction. 
 * @export
 * @enum {string}
 */

export const TransactionTypeEnum = {
    NUMBER_16716: 16716,
    NUMBER_16963: 16963,
    NUMBER_16707: 16707,
    NUMBER_16972: 16972,
    NUMBER_16705: 16705,
    NUMBER_16961: 16961,
    NUMBER_16717: 16717,
    NUMBER_16973: 16973,
    NUMBER_17229: 17229,
    NUMBER_16718: 16718,
    NUMBER_16974: 16974,
    NUMBER_17230: 17230,
    NUMBER_16708: 16708,
    NUMBER_16964: 16964,
    NUMBER_17220: 17220,
    NUMBER_16725: 16725,
    NUMBER_16712: 16712,
    NUMBER_16722: 16722,
    NUMBER_16978: 16978,
    NUMBER_16720: 16720,
    NUMBER_16976: 16976,
    NUMBER_17232: 17232,
    NUMBER_16721: 16721,
    NUMBER_16977: 16977,
    NUMBER_16724: 16724
} as const;

export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];


/**
 * 
 * @export
 * @interface TransferNetworkPropertiesDTO
 */
export interface TransferNetworkPropertiesDTO {
    /**
     * Maximum transaction message size.
     * @type {string}
     * @memberof TransferNetworkPropertiesDTO
     */
    'maxMessageSize'?: string;
}
/**
 * 
 * @export
 * @interface TransferTransactionBodyDTO
 */
export interface TransferTransactionBodyDTO {
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof TransferTransactionBodyDTO
     */
    'recipientAddress': string;
    /**
     * Array of mosaics sent to the recipient. 
     * @type {Array<UnresolvedMosaic>}
     * @memberof TransferTransactionBodyDTO
     */
    'mosaics': Array<UnresolvedMosaic>;
    /**
     * Transfer transaction message
     * @type {string}
     * @memberof TransferTransactionBodyDTO
     */
    'message'?: string;
}
/**
 * Transaction to transfer mosaics and a message to another account.
 * @export
 * @interface TransferTransactionDTO
 */
export interface TransferTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof TransferTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof TransferTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof TransferTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TransferTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'deadline': string;
    /**
     * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA.  Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA 
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'recipientAddress': string;
    /**
     * Array of mosaics sent to the recipient. 
     * @type {Array<UnresolvedMosaic>}
     * @memberof TransferTransactionDTO
     */
    'mosaics': Array<UnresolvedMosaic>;
    /**
     * Transfer transaction message
     * @type {string}
     * @memberof TransferTransactionDTO
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface UnlockedAccountDTO
 */
export interface UnlockedAccountDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof UnlockedAccountDTO
     */
    'unlockedAccount': Array<string>;
}
/**
 * 
 * @export
 * @interface UnresolvedMosaic
 */
export interface UnresolvedMosaic {
    /**
     * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias) is used instead of the real mosaic identifier. 
     * @type {string}
     * @memberof UnresolvedMosaic
     */
    'id': string;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof UnresolvedMosaic
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface VerifiableEntityDTO
 */
export interface VerifiableEntityDTO {
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof VerifiableEntityDTO
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface VotingKeyLinkNetworkPropertiesDTO
 */
export interface VotingKeyLinkNetworkPropertiesDTO {
    /**
     * to trigger plugin load
     * @type {string}
     * @memberof VotingKeyLinkNetworkPropertiesDTO
     */
    'dummy'?: string;
}
/**
 * 
 * @export
 * @interface VotingKeyLinkTransactionBodyDTO
 */
export interface VotingKeyLinkTransactionBodyDTO {
    /**
     * 32 bytes voting public key.
     * @type {string}
     * @memberof VotingKeyLinkTransactionBodyDTO
     */
    'linkedPublicKey': string;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof VotingKeyLinkTransactionBodyDTO
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof VotingKeyLinkTransactionBodyDTO
     */
    'endEpoch': number;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof VotingKeyLinkTransactionBodyDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * Transaction to associate a BLS public key with an account. Required for node operators willing to vote finalized blocks. 
 * @export
 * @interface VotingKeyLinkTransactionDTO
 */
export interface VotingKeyLinkTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'deadline': string;
    /**
     * 32 bytes voting public key.
     * @type {string}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'startEpoch': number;
    /**
     * Finalization Epoch
     * @type {number}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'endEpoch': number;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof VotingKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * 
 * @export
 * @interface VrfKeyLinkNetworkPropertiesDTO
 */
export interface VrfKeyLinkNetworkPropertiesDTO {
    /**
     * to trigger plugin load
     * @type {string}
     * @memberof VrfKeyLinkNetworkPropertiesDTO
     */
    'dummy'?: string;
}
/**
 * 
 * @export
 * @interface VrfKeyLinkTransactionBodyDTO
 */
export interface VrfKeyLinkTransactionBodyDTO {
    /**
     * Public key.
     * @type {string}
     * @memberof VrfKeyLinkTransactionBodyDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof VrfKeyLinkTransactionBodyDTO
     */
    'linkAction': LinkActionEnum;
}
/**
 * Transaction to link an account with a VRF public key. The key is used to randomize block production and leader/participant selection. Required for all harvesting eligible accounts. 
 * @export
 * @interface VrfKeyLinkTransactionDTO
 */
export interface VrfKeyLinkTransactionDTO {
    /**
     * A number that allows uint 32 values.
     * @type {number}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'size': number;
    /**
     * Entity\'s signature generated by the signer.
     * @type {string}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'signature': string;
    /**
     * Public key.
     * @type {string}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'signerPublicKey': string;
    /**
     * Entity version.
     * @type {number}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'version': number;
    /**
     * 
     * @type {NetworkTypeEnum}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'network': NetworkTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'type': number;
    /**
     * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
     * @type {string}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'maxFee': string;
    /**
     * Duration expressed in number of blocks.
     * @type {string}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'deadline': string;
    /**
     * Public key.
     * @type {string}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'linkedPublicKey': string;
    /**
     * 
     * @type {LinkActionEnum}
     * @memberof VrfKeyLinkTransactionDTO
     */
    'linkAction': LinkActionEnum;
}

/**
 * AccountRoutesApi - axios parameter creator
 * @export
 */
export const AccountRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountInfo', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfoMerkle: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountInfoMerkle', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/merkle`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsInfo: async (accountIds?: AccountIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter. 
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: AccountOrderByEnum, mosaicId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (mosaicId !== undefined) {
                localVarQueryParameter['mosaicId'] = mosaicId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountRoutesApi - functional programming interface
 * @export
 */
export const AccountRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfo(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfo(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfoMerkle(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfoMerkle(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsInfo(accountIds?: AccountIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsInfo(accountIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter. 
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: AccountOrderByEnum, mosaicId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountRoutesApi - factory interface
 * @export
 */
export const AccountRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountRoutesApiFp(configuration)
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo(accountId: string, options?: any): AxiosPromise<AccountInfoDTO> {
            return localVarFp.getAccountInfo(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfoMerkle(accountId: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getAccountInfoMerkle(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsInfo(accountIds?: AccountIds, options?: any): AxiosPromise<Array<AccountInfoDTO>> {
            return localVarFp.getAccountsInfo(accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter. 
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: AccountOrderByEnum, mosaicId?: string, options?: any): AxiosPromise<AccountPage> {
            return localVarFp.searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountInfo operation in AccountRoutesApi.
 * @export
 * @interface AccountRoutesApiGetAccountInfoRequest
 */
export interface AccountRoutesApiGetAccountInfoRequest {
    /**
     * Account public key or address encoded using a 32-character set.
     * @type {string}
     * @memberof AccountRoutesApiGetAccountInfo
     */
    readonly accountId: string
}

/**
 * Request parameters for getAccountInfoMerkle operation in AccountRoutesApi.
 * @export
 * @interface AccountRoutesApiGetAccountInfoMerkleRequest
 */
export interface AccountRoutesApiGetAccountInfoMerkleRequest {
    /**
     * Account public key or address encoded using a 32-character set.
     * @type {string}
     * @memberof AccountRoutesApiGetAccountInfoMerkle
     */
    readonly accountId: string
}

/**
 * Request parameters for getAccountsInfo operation in AccountRoutesApi.
 * @export
 * @interface AccountRoutesApiGetAccountsInfoRequest
 */
export interface AccountRoutesApiGetAccountsInfoRequest {
    /**
     * 
     * @type {AccountIds}
     * @memberof AccountRoutesApiGetAccountsInfo
     */
    readonly accountIds?: AccountIds
}

/**
 * Request parameters for searchAccounts operation in AccountRoutesApi.
 * @export
 * @interface AccountRoutesApiSearchAccountsRequest
 */
export interface AccountRoutesApiSearchAccountsRequest {
    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly order?: Order

    /**
     * Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter. 
     * @type {AccountOrderByEnum}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly orderBy?: AccountOrderByEnum

    /**
     * Filter by mosaic identifier.
     * @type {string}
     * @memberof AccountRoutesApiSearchAccounts
     */
    readonly mosaicId?: string
}

/**
 * AccountRoutesApi - object-oriented interface
 * @export
 * @class AccountRoutesApi
 * @extends {BaseAPI}
 */
export class AccountRoutesApi extends BaseAPI {
    /**
     * Returns the account information.
     * @summary Get account information
     * @param {AccountRoutesApiGetAccountInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    public getAccountInfo(requestParameters: AccountRoutesApiGetAccountInfoRequest, options?: AxiosRequestConfig) {
        return AccountRoutesApiFp(this.configuration).getAccountInfo(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the account merkle information.
     * @summary Get account merkle information
     * @param {AccountRoutesApiGetAccountInfoMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    public getAccountInfoMerkle(requestParameters: AccountRoutesApiGetAccountInfoMerkleRequest, options?: AxiosRequestConfig) {
        return AccountRoutesApiFp(this.configuration).getAccountInfoMerkle(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the account information for an array of accounts.
     * @summary Get accounts information
     * @param {AccountRoutesApiGetAccountsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    public getAccountsInfo(requestParameters: AccountRoutesApiGetAccountsInfoRequest = {}, options?: AxiosRequestConfig) {
        return AccountRoutesApiFp(this.configuration).getAccountsInfo(requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of accounts.
     * @summary Search accounts
     * @param {AccountRoutesApiSearchAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    public searchAccounts(requestParameters: AccountRoutesApiSearchAccountsRequest = {}, options?: AxiosRequestConfig) {
        return AccountRoutesApiFp(this.configuration).searchAccounts(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, requestParameters.orderBy, requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockRoutesApi - axios parameter creator
 * @export
 */
export const BlockRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: async (height: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getBlockByHeight', 'height', height)
            const localVarPath = `/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleReceipts: async (height: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getMerkleReceipts', 'height', height)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getMerkleReceipts', 'hash', hash)
            const localVarPath = `/blocks/{height}/statements/{hash}/merkle`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleTransaction: async (height: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getMerkleTransaction', 'height', height)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getMerkleTransaction', 'hash', hash)
            const localVarPath = `/blocks/{height}/transactions/{hash}/merkle`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBlocks: async (signerPublicKey?: string, beneficiaryAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: BlockOrderByEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }

            if (beneficiaryAddress !== undefined) {
                localVarQueryParameter['beneficiaryAddress'] = beneficiaryAddress;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockRoutesApi - functional programming interface
 * @export
 */
export const BlockRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeight(height: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockByHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerkleReceipts(height: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleProofInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerkleReceipts(height, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerkleTransaction(height: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleProofInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerkleTransaction(height, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBlocks(signerPublicKey?: string, beneficiaryAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: BlockOrderByEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockRoutesApi - factory interface
 * @export
 */
export const BlockRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockRoutesApiFp(configuration)
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight(height: string, options?: any): AxiosPromise<BlockInfoDTO> {
            return localVarFp.getBlockByHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleReceipts(height: string, hash: string, options?: any): AxiosPromise<MerkleProofInfoDTO> {
            return localVarFp.getMerkleReceipts(height, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleTransaction(height: string, hash: string, options?: any): AxiosPromise<MerkleProofInfoDTO> {
            return localVarFp.getMerkleTransaction(height, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBlocks(signerPublicKey?: string, beneficiaryAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, orderBy?: BlockOrderByEnum, options?: any): AxiosPromise<BlockPage> {
            return localVarFp.searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBlockByHeight operation in BlockRoutesApi.
 * @export
 * @interface BlockRoutesApiGetBlockByHeightRequest
 */
export interface BlockRoutesApiGetBlockByHeightRequest {
    /**
     * Block height.
     * @type {string}
     * @memberof BlockRoutesApiGetBlockByHeight
     */
    readonly height: string
}

/**
 * Request parameters for getMerkleReceipts operation in BlockRoutesApi.
 * @export
 * @interface BlockRoutesApiGetMerkleReceiptsRequest
 */
export interface BlockRoutesApiGetMerkleReceiptsRequest {
    /**
     * Block height.
     * @type {string}
     * @memberof BlockRoutesApiGetMerkleReceipts
     */
    readonly height: string

    /**
     * Receipt hash.
     * @type {string}
     * @memberof BlockRoutesApiGetMerkleReceipts
     */
    readonly hash: string
}

/**
 * Request parameters for getMerkleTransaction operation in BlockRoutesApi.
 * @export
 * @interface BlockRoutesApiGetMerkleTransactionRequest
 */
export interface BlockRoutesApiGetMerkleTransactionRequest {
    /**
     * Block height.
     * @type {string}
     * @memberof BlockRoutesApiGetMerkleTransaction
     */
    readonly height: string

    /**
     * Transaction hash.
     * @type {string}
     * @memberof BlockRoutesApiGetMerkleTransaction
     */
    readonly hash: string
}

/**
 * Request parameters for searchBlocks operation in BlockRoutesApi.
 * @export
 * @interface BlockRoutesApiSearchBlocksRequest
 */
export interface BlockRoutesApiSearchBlocksRequest {
    /**
     * Filter by public key of the account signing the entity.
     * @type {string}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly signerPublicKey?: string

    /**
     * Filter by beneficiary address.
     * @type {string}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly beneficiaryAddress?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly order?: Order

    /**
     * Sort responses by the property set. 
     * @type {BlockOrderByEnum}
     * @memberof BlockRoutesApiSearchBlocks
     */
    readonly orderBy?: BlockOrderByEnum
}

/**
 * BlockRoutesApi - object-oriented interface
 * @export
 * @class BlockRoutesApi
 * @extends {BaseAPI}
 */
export class BlockRoutesApi extends BaseAPI {
    /**
     * Gets a block from the chain that has the given height.
     * @summary Get block information
     * @param {BlockRoutesApiGetBlockByHeightRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    public getBlockByHeight(requestParameters: BlockRoutesApiGetBlockByHeightRequest, options?: AxiosRequestConfig) {
        return BlockRoutesApiFp(this.configuration).getBlockByHeight(requestParameters.height, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block. 
     * @summary Get the merkle path for a given a receipt statement hash and block
     * @param {BlockRoutesApiGetMerkleReceiptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    public getMerkleReceipts(requestParameters: BlockRoutesApiGetMerkleReceiptsRequest, options?: AxiosRequestConfig) {
        return BlockRoutesApiFp(this.configuration).getMerkleReceipts(requestParameters.height, requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block. 
     * @summary Get the merkle path for a given a transaction and block
     * @param {BlockRoutesApiGetMerkleTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    public getMerkleTransaction(requestParameters: BlockRoutesApiGetMerkleTransactionRequest, options?: AxiosRequestConfig) {
        return BlockRoutesApiFp(this.configuration).getMerkleTransaction(requestParameters.height, requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of bocks.
     * @summary Search blocks
     * @param {BlockRoutesApiSearchBlocksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    public searchBlocks(requestParameters: BlockRoutesApiSearchBlocksRequest = {}, options?: AxiosRequestConfig) {
        return BlockRoutesApiFp(this.configuration).searchBlocks(requestParameters.signerPublicKey, requestParameters.beneficiaryAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, requestParameters.orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChainRoutesApi - axios parameter creator
 * @export
 */
export const ChainRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty  time elapsed since last block 
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chain/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChainRoutesApi - functional programming interface
 * @export
 */
export const ChainRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChainRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty  time elapsed since last block 
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChainInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChainInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChainRoutesApi - factory interface
 * @export
 */
export const ChainRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChainRoutesApiFp(configuration)
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty  time elapsed since last block 
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo(options?: any): AxiosPromise<ChainInfoDTO> {
            return localVarFp.getChainInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChainRoutesApi - object-oriented interface
 * @export
 * @class ChainRoutesApi
 * @extends {BaseAPI}
 */
export class ChainRoutesApi extends BaseAPI {
    /**
     * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty  time elapsed since last block 
     * @summary Get the current information of the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainRoutesApi
     */
    public getChainInfo(options?: AxiosRequestConfig) {
        return ChainRoutesApiFp(this.configuration).getChainInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FinalizationRoutesApi - axios parameter creator
 * @export
 */
export const FinalizationRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtEpoch: async (epoch: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'epoch' is not null or undefined
            assertParamExists('getFinalizationProofAtEpoch', 'epoch', epoch)
            const localVarPath = `/finalization/proof/epoch/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtHeight: async (height: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getFinalizationProofAtHeight', 'height', height)
            const localVarPath = `/finalization/proof/height/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FinalizationRoutesApi - functional programming interface
 * @export
 */
export const FinalizationRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FinalizationRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalizationProofAtEpoch(epoch: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalizationProofDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalizationProofAtEpoch(epoch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalizationProofAtHeight(height: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalizationProofDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalizationProofAtHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FinalizationRoutesApi - factory interface
 * @export
 */
export const FinalizationRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FinalizationRoutesApiFp(configuration)
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtEpoch(epoch: number, options?: any): AxiosPromise<FinalizationProofDTO> {
            return localVarFp.getFinalizationProofAtEpoch(epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtHeight(height: string, options?: any): AxiosPromise<FinalizationProofDTO> {
            return localVarFp.getFinalizationProofAtHeight(height, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFinalizationProofAtEpoch operation in FinalizationRoutesApi.
 * @export
 * @interface FinalizationRoutesApiGetFinalizationProofAtEpochRequest
 */
export interface FinalizationRoutesApiGetFinalizationProofAtEpochRequest {
    /**
     * Finalization epoch.
     * @type {number}
     * @memberof FinalizationRoutesApiGetFinalizationProofAtEpoch
     */
    readonly epoch: number
}

/**
 * Request parameters for getFinalizationProofAtHeight operation in FinalizationRoutesApi.
 * @export
 * @interface FinalizationRoutesApiGetFinalizationProofAtHeightRequest
 */
export interface FinalizationRoutesApiGetFinalizationProofAtHeightRequest {
    /**
     * Block height.
     * @type {string}
     * @memberof FinalizationRoutesApiGetFinalizationProofAtHeight
     */
    readonly height: string
}

/**
 * FinalizationRoutesApi - object-oriented interface
 * @export
 * @class FinalizationRoutesApi
 * @extends {BaseAPI}
 */
export class FinalizationRoutesApi extends BaseAPI {
    /**
     * Gets finalization proof for the greatest height associated with the given epoch.
     * @summary Get finalization proof
     * @param {FinalizationRoutesApiGetFinalizationProofAtEpochRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinalizationRoutesApi
     */
    public getFinalizationProofAtEpoch(requestParameters: FinalizationRoutesApiGetFinalizationProofAtEpochRequest, options?: AxiosRequestConfig) {
        return FinalizationRoutesApiFp(this.configuration).getFinalizationProofAtEpoch(requestParameters.epoch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets finalization proof at the given height.
     * @summary Get finalization proof
     * @param {FinalizationRoutesApiGetFinalizationProofAtHeightRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinalizationRoutesApi
     */
    public getFinalizationProofAtHeight(requestParameters: FinalizationRoutesApiGetFinalizationProofAtHeightRequest, options?: AxiosRequestConfig) {
        return FinalizationRoutesApiFp(this.configuration).getFinalizationProofAtHeight(requestParameters.height, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HashLockRoutesApi - axios parameter creator
 * @export
 */
export const HashLockRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLock: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getHashLock', 'hash', hash)
            const localVarPath = `/lock/hash/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLockMerkle: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getHashLockMerkle', 'hash', hash)
            const localVarPath = `/lock/hash/{hash}/merkle`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHashLock: async (address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lock/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HashLockRoutesApi - functional programming interface
 * @export
 */
export const HashLockRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HashLockRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHashLock(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashLockInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHashLock(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHashLockMerkle(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHashLockMerkle(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchHashLock(address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashLockPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchHashLock(address, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HashLockRoutesApi - factory interface
 * @export
 */
export const HashLockRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HashLockRoutesApiFp(configuration)
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLock(hash: string, options?: any): AxiosPromise<HashLockInfoDTO> {
            return localVarFp.getHashLock(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLockMerkle(hash: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getHashLockMerkle(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHashLock(address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<HashLockPage> {
            return localVarFp.searchHashLock(address, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHashLock operation in HashLockRoutesApi.
 * @export
 * @interface HashLockRoutesApiGetHashLockRequest
 */
export interface HashLockRoutesApiGetHashLockRequest {
    /**
     * Filter by hash.
     * @type {string}
     * @memberof HashLockRoutesApiGetHashLock
     */
    readonly hash: string
}

/**
 * Request parameters for getHashLockMerkle operation in HashLockRoutesApi.
 * @export
 * @interface HashLockRoutesApiGetHashLockMerkleRequest
 */
export interface HashLockRoutesApiGetHashLockMerkleRequest {
    /**
     * Filter by hash.
     * @type {string}
     * @memberof HashLockRoutesApiGetHashLockMerkle
     */
    readonly hash: string
}

/**
 * Request parameters for searchHashLock operation in HashLockRoutesApi.
 * @export
 * @interface HashLockRoutesApiSearchHashLockRequest
 */
export interface HashLockRoutesApiSearchHashLockRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof HashLockRoutesApiSearchHashLock
     */
    readonly address?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof HashLockRoutesApiSearchHashLock
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof HashLockRoutesApiSearchHashLock
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof HashLockRoutesApiSearchHashLock
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof HashLockRoutesApiSearchHashLock
     */
    readonly order?: Order
}

/**
 * HashLockRoutesApi - object-oriented interface
 * @export
 * @class HashLockRoutesApi
 * @extends {BaseAPI}
 */
export class HashLockRoutesApi extends BaseAPI {
    /**
     * Gets the hash lock for a given hash.
     * @summary Get hash lock information
     * @param {HashLockRoutesApiGetHashLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    public getHashLock(requestParameters: HashLockRoutesApiGetHashLockRequest, options?: AxiosRequestConfig) {
        return HashLockRoutesApiFp(this.configuration).getHashLock(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the hash lock merkle for a given hash.
     * @summary Get hash lock merkle information
     * @param {HashLockRoutesApiGetHashLockMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    public getHashLockMerkle(requestParameters: HashLockRoutesApiGetHashLockMerkleRequest, options?: AxiosRequestConfig) {
        return HashLockRoutesApiFp(this.configuration).getHashLockMerkle(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of hash locks.
     * @summary Search hash lock entries
     * @param {HashLockRoutesApiSearchHashLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    public searchHashLock(requestParameters: HashLockRoutesApiSearchHashLockRequest = {}, options?: AxiosRequestConfig) {
        return HashLockRoutesApiFp(this.configuration).searchHashLock(requestParameters.address, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetadataRoutesApi - axios parameter creator
 * @export
 */
export const MetadataRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMetadata', 'compositeHash', compositeHash)
            const localVarPath = `/metadata/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataMerkle: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMetadataMerkle', 'compositeHash', compositeHash)
            const localVarPath = `/metadata/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMetadataEntries: async (sourceAddress?: string, targetAddress?: string, scopedMetadataKey?: string, targetId?: string, metadataType?: MetadataTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceAddress !== undefined) {
                localVarQueryParameter['sourceAddress'] = sourceAddress;
            }

            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }

            if (scopedMetadataKey !== undefined) {
                localVarQueryParameter['scopedMetadataKey'] = scopedMetadataKey;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (metadataType !== undefined) {
                localVarQueryParameter['metadataType'] = metadataType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataRoutesApi - functional programming interface
 * @export
 */
export const MetadataRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataMerkle(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMetadataEntries(sourceAddress?: string, targetAddress?: string, scopedMetadataKey?: string, targetId?: string, metadataType?: MetadataTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataRoutesApi - factory interface
 * @export
 */
export const MetadataRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataRoutesApiFp(configuration)
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(compositeHash: string, options?: any): AxiosPromise<MetadataInfoDTO> {
            return localVarFp.getMetadata(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataMerkle(compositeHash: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getMetadataMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMetadataEntries(sourceAddress?: string, targetAddress?: string, scopedMetadataKey?: string, targetId?: string, metadataType?: MetadataTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<MetadataPage> {
            return localVarFp.searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadata operation in MetadataRoutesApi.
 * @export
 * @interface MetadataRoutesApiGetMetadataRequest
 */
export interface MetadataRoutesApiGetMetadataRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof MetadataRoutesApiGetMetadata
     */
    readonly compositeHash: string
}

/**
 * Request parameters for getMetadataMerkle operation in MetadataRoutesApi.
 * @export
 * @interface MetadataRoutesApiGetMetadataMerkleRequest
 */
export interface MetadataRoutesApiGetMetadataMerkleRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof MetadataRoutesApiGetMetadataMerkle
     */
    readonly compositeHash: string
}

/**
 * Request parameters for searchMetadataEntries operation in MetadataRoutesApi.
 * @export
 * @interface MetadataRoutesApiSearchMetadataEntriesRequest
 */
export interface MetadataRoutesApiSearchMetadataEntriesRequest {
    /**
     * Filter by address sending the metadata entry.
     * @type {string}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly sourceAddress?: string

    /**
     * Filter by target address.
     * @type {string}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly targetAddress?: string

    /**
     * Filter by metadata key.
     * @type {string}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly scopedMetadataKey?: string

    /**
     * Filter by namespace or mosaic id.
     * @type {string}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly targetId?: string

    /**
     * Filter by metadata type.
     * @type {MetadataTypeEnum}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly metadataType?: MetadataTypeEnum

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof MetadataRoutesApiSearchMetadataEntries
     */
    readonly order?: Order
}

/**
 * MetadataRoutesApi - object-oriented interface
 * @export
 * @class MetadataRoutesApi
 * @extends {BaseAPI}
 */
export class MetadataRoutesApi extends BaseAPI {
    /**
     * Gets the metadata for a given composite hash.
     * @summary Get metadata information
     * @param {MetadataRoutesApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    public getMetadata(requestParameters: MetadataRoutesApiGetMetadataRequest, options?: AxiosRequestConfig) {
        return MetadataRoutesApiFp(this.configuration).getMetadata(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the metadata merkle for a given composite hash.
     * @summary Get metadata merkle information
     * @param {MetadataRoutesApiGetMetadataMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    public getMetadataMerkle(requestParameters: MetadataRoutesApiGetMetadataMerkleRequest, options?: AxiosRequestConfig) {
        return MetadataRoutesApiFp(this.configuration).getMetadataMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of metadata.
     * @summary Search metadata entries
     * @param {MetadataRoutesApiSearchMetadataEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    public searchMetadataEntries(requestParameters: MetadataRoutesApiSearchMetadataEntriesRequest = {}, options?: AxiosRequestConfig) {
        return MetadataRoutesApiFp(this.configuration).searchMetadataEntries(requestParameters.sourceAddress, requestParameters.targetAddress, requestParameters.scopedMetadataKey, requestParameters.targetId, requestParameters.metadataType, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MosaicRoutesApi - axios parameter creator
 * @export
 */
export const MosaicRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaic: async (mosaicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mosaicId' is not null or undefined
            assertParamExists('getMosaic', 'mosaicId', mosaicId)
            const localVarPath = `/mosaics/{mosaicId}`
                .replace(`{${"mosaicId"}}`, encodeURIComponent(String(mosaicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicMerkle: async (mosaicId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mosaicId' is not null or undefined
            assertParamExists('getMosaicMerkle', 'mosaicId', mosaicId)
            const localVarPath = `/mosaics/{mosaicId}/merkle`
                .replace(`{${"mosaicId"}}`, encodeURIComponent(String(mosaicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaics: async (mosaicIds: MosaicIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mosaicIds' is not null or undefined
            assertParamExists('getMosaics', 'mosaicIds', mosaicIds)
            const localVarPath = `/mosaics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mosaicIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaics: async (ownerAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mosaics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ownerAddress !== undefined) {
                localVarQueryParameter['ownerAddress'] = ownerAddress;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MosaicRoutesApi - functional programming interface
 * @export
 */
export const MosaicRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MosaicRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaic(mosaicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MosaicInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaic(mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicMerkle(mosaicId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicMerkle(mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaics(mosaicIds: MosaicIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MosaicInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaics(mosaicIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaics(ownerAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MosaicPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MosaicRoutesApi - factory interface
 * @export
 */
export const MosaicRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MosaicRoutesApiFp(configuration)
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaic(mosaicId: string, options?: any): AxiosPromise<MosaicInfoDTO> {
            return localVarFp.getMosaic(mosaicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicMerkle(mosaicId: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getMosaicMerkle(mosaicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaics(mosaicIds: MosaicIds, options?: any): AxiosPromise<Array<MosaicInfoDTO>> {
            return localVarFp.getMosaics(mosaicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaics(ownerAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<MosaicPage> {
            return localVarFp.searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMosaic operation in MosaicRoutesApi.
 * @export
 * @interface MosaicRoutesApiGetMosaicRequest
 */
export interface MosaicRoutesApiGetMosaicRequest {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicRoutesApiGetMosaic
     */
    readonly mosaicId: string
}

/**
 * Request parameters for getMosaicMerkle operation in MosaicRoutesApi.
 * @export
 * @interface MosaicRoutesApiGetMosaicMerkleRequest
 */
export interface MosaicRoutesApiGetMosaicMerkleRequest {
    /**
     * Mosaic identifier.
     * @type {string}
     * @memberof MosaicRoutesApiGetMosaicMerkle
     */
    readonly mosaicId: string
}

/**
 * Request parameters for getMosaics operation in MosaicRoutesApi.
 * @export
 * @interface MosaicRoutesApiGetMosaicsRequest
 */
export interface MosaicRoutesApiGetMosaicsRequest {
    /**
     * 
     * @type {MosaicIds}
     * @memberof MosaicRoutesApiGetMosaics
     */
    readonly mosaicIds: MosaicIds
}

/**
 * Request parameters for searchMosaics operation in MosaicRoutesApi.
 * @export
 * @interface MosaicRoutesApiSearchMosaicsRequest
 */
export interface MosaicRoutesApiSearchMosaicsRequest {
    /**
     * Filter by owner address.
     * @type {string}
     * @memberof MosaicRoutesApiSearchMosaics
     */
    readonly ownerAddress?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof MosaicRoutesApiSearchMosaics
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof MosaicRoutesApiSearchMosaics
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof MosaicRoutesApiSearchMosaics
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof MosaicRoutesApiSearchMosaics
     */
    readonly order?: Order
}

/**
 * MosaicRoutesApi - object-oriented interface
 * @export
 * @class MosaicRoutesApi
 * @extends {BaseAPI}
 */
export class MosaicRoutesApi extends BaseAPI {
    /**
     * Gets the mosaic definition for a given mosaic identifier.
     * @summary Get mosaic information
     * @param {MosaicRoutesApiGetMosaicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    public getMosaic(requestParameters: MosaicRoutesApiGetMosaicRequest, options?: AxiosRequestConfig) {
        return MosaicRoutesApiFp(this.configuration).getMosaic(requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the mosaic definition merkle for a given mosaic identifier.
     * @summary Get mosaic merkle information
     * @param {MosaicRoutesApiGetMosaicMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    public getMosaicMerkle(requestParameters: MosaicRoutesApiGetMosaicMerkleRequest, options?: AxiosRequestConfig) {
        return MosaicRoutesApiFp(this.configuration).getMosaicMerkle(requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of mosaic definition.
     * @summary Get mosaics information for an array of mosaics
     * @param {MosaicRoutesApiGetMosaicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    public getMosaics(requestParameters: MosaicRoutesApiGetMosaicsRequest, options?: AxiosRequestConfig) {
        return MosaicRoutesApiFp(this.configuration).getMosaics(requestParameters.mosaicIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of mosaics.
     * @summary Search mosaics
     * @param {MosaicRoutesApiSearchMosaicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    public searchMosaics(requestParameters: MosaicRoutesApiSearchMosaicsRequest = {}, options?: AxiosRequestConfig) {
        return MosaicRoutesApiFp(this.configuration).searchMosaics(requestParameters.ownerAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MultisigRoutesApi - axios parameter creator
 * @export
 */
export const MultisigRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisig: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisig', 'address', address)
            const localVarPath = `/account/{address}/multisig`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigGraph: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisigGraph', 'address', address)
            const localVarPath = `/account/{address}/multisig/graph`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigMerkle: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisigMerkle', 'address', address)
            const localVarPath = `/account/{address}/multisig/merkle`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MultisigRoutesApi - functional programming interface
 * @export
 */
export const MultisigRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MultisigRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisig(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultisigAccountInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisig(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisigGraph(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MultisigAccountGraphInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisigGraph(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisigMerkle(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisigMerkle(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MultisigRoutesApi - factory interface
 * @export
 */
export const MultisigRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MultisigRoutesApiFp(configuration)
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisig(address: string, options?: any): AxiosPromise<MultisigAccountInfoDTO> {
            return localVarFp.getAccountMultisig(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigGraph(address: string, options?: any): AxiosPromise<Array<MultisigAccountGraphInfoDTO>> {
            return localVarFp.getAccountMultisigGraph(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigMerkle(address: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getAccountMultisigMerkle(address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountMultisig operation in MultisigRoutesApi.
 * @export
 * @interface MultisigRoutesApiGetAccountMultisigRequest
 */
export interface MultisigRoutesApiGetAccountMultisigRequest {
    /**
     * Account address.
     * @type {string}
     * @memberof MultisigRoutesApiGetAccountMultisig
     */
    readonly address: string
}

/**
 * Request parameters for getAccountMultisigGraph operation in MultisigRoutesApi.
 * @export
 * @interface MultisigRoutesApiGetAccountMultisigGraphRequest
 */
export interface MultisigRoutesApiGetAccountMultisigGraphRequest {
    /**
     * Account address.
     * @type {string}
     * @memberof MultisigRoutesApiGetAccountMultisigGraph
     */
    readonly address: string
}

/**
 * Request parameters for getAccountMultisigMerkle operation in MultisigRoutesApi.
 * @export
 * @interface MultisigRoutesApiGetAccountMultisigMerkleRequest
 */
export interface MultisigRoutesApiGetAccountMultisigMerkleRequest {
    /**
     * Account address.
     * @type {string}
     * @memberof MultisigRoutesApiGetAccountMultisigMerkle
     */
    readonly address: string
}

/**
 * MultisigRoutesApi - object-oriented interface
 * @export
 * @class MultisigRoutesApi
 * @extends {BaseAPI}
 */
export class MultisigRoutesApi extends BaseAPI {
    /**
     * Returns the multisig account information.
     * @summary Get multisig account information
     * @param {MultisigRoutesApiGetAccountMultisigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    public getAccountMultisig(requestParameters: MultisigRoutesApiGetAccountMultisigRequest, options?: AxiosRequestConfig) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisig(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the multisig account graph.
     * @summary Get multisig account graph information
     * @param {MultisigRoutesApiGetAccountMultisigGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    public getAccountMultisigGraph(requestParameters: MultisigRoutesApiGetAccountMultisigGraphRequest, options?: AxiosRequestConfig) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisigGraph(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the multisig account merkle information.
     * @summary Get multisig account merkle information
     * @param {MultisigRoutesApiGetAccountMultisigMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    public getAccountMultisigMerkle(requestParameters: MultisigRoutesApiGetAccountMultisigMerkleRequest, options?: AxiosRequestConfig) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisigMerkle(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NamespaceRoutesApi - axios parameter creator
 * @export
 */
export const NamespaceRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsNames: async (addresses: Addresses, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('getAccountsNames', 'addresses', addresses)
            const localVarPath = `/namespaces/account/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addresses, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicsNames: async (mosaicIds: MosaicIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mosaicIds' is not null or undefined
            assertParamExists('getMosaicsNames', 'mosaicIds', mosaicIds)
            const localVarPath = `/namespaces/mosaic/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mosaicIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (namespaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespaceId' is not null or undefined
            assertParamExists('getNamespace', 'namespaceId', namespaceId)
            const localVarPath = `/namespaces/{namespaceId}`
                .replace(`{${"namespaceId"}}`, encodeURIComponent(String(namespaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMerkle: async (namespaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespaceId' is not null or undefined
            assertParamExists('getNamespaceMerkle', 'namespaceId', namespaceId)
            const localVarPath = `/namespaces/{namespaceId}/merkle`
                .replace(`{${"namespaceId"}}`, encodeURIComponent(String(namespaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesNames: async (namespaceIds: NamespaceIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespaceIds' is not null or undefined
            assertParamExists('getNamespacesNames', 'namespaceIds', namespaceIds)
            const localVarPath = `/namespaces/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(namespaceIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNamespaces: async (ownerAddress?: string, registrationType?: NamespaceRegistrationTypeEnum, level0?: string, aliasType?: AliasTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ownerAddress !== undefined) {
                localVarQueryParameter['ownerAddress'] = ownerAddress;
            }

            if (registrationType !== undefined) {
                localVarQueryParameter['registrationType'] = registrationType;
            }

            if (level0 !== undefined) {
                localVarQueryParameter['level0'] = level0;
            }

            if (aliasType !== undefined) {
                localVarQueryParameter['aliasType'] = aliasType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespaceRoutesApi - functional programming interface
 * @export
 */
export const NamespaceRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NamespaceRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsNames(addresses: Addresses, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsNamesDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsNames(addresses, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicsNames(mosaicIds: MosaicIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MosaicsNamesDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicsNames(mosaicIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(namespaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespaceInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(namespaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceMerkle(namespaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceMerkle(namespaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesNames(namespaceIds: NamespaceIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NamespaceNameDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesNames(namespaceIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchNamespaces(ownerAddress?: string, registrationType?: NamespaceRegistrationTypeEnum, level0?: string, aliasType?: AliasTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespacePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NamespaceRoutesApi - factory interface
 * @export
 */
export const NamespaceRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NamespaceRoutesApiFp(configuration)
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsNames(addresses: Addresses, options?: any): AxiosPromise<AccountsNamesDTO> {
            return localVarFp.getAccountsNames(addresses, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicsNames(mosaicIds: MosaicIds, options?: any): AxiosPromise<MosaicsNamesDTO> {
            return localVarFp.getMosaicsNames(mosaicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(namespaceId: string, options?: any): AxiosPromise<NamespaceInfoDTO> {
            return localVarFp.getNamespace(namespaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMerkle(namespaceId: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getNamespaceMerkle(namespaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesNames(namespaceIds: NamespaceIds, options?: any): AxiosPromise<Array<NamespaceNameDTO>> {
            return localVarFp.getNamespacesNames(namespaceIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNamespaces(ownerAddress?: string, registrationType?: NamespaceRegistrationTypeEnum, level0?: string, aliasType?: AliasTypeEnum, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<NamespacePage> {
            return localVarFp.searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountsNames operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiGetAccountsNamesRequest
 */
export interface NamespaceRoutesApiGetAccountsNamesRequest {
    /**
     * 
     * @type {Addresses}
     * @memberof NamespaceRoutesApiGetAccountsNames
     */
    readonly addresses: Addresses
}

/**
 * Request parameters for getMosaicsNames operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiGetMosaicsNamesRequest
 */
export interface NamespaceRoutesApiGetMosaicsNamesRequest {
    /**
     * 
     * @type {MosaicIds}
     * @memberof NamespaceRoutesApiGetMosaicsNames
     */
    readonly mosaicIds: MosaicIds
}

/**
 * Request parameters for getNamespace operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiGetNamespaceRequest
 */
export interface NamespaceRoutesApiGetNamespaceRequest {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRoutesApiGetNamespace
     */
    readonly namespaceId: string
}

/**
 * Request parameters for getNamespaceMerkle operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiGetNamespaceMerkleRequest
 */
export interface NamespaceRoutesApiGetNamespaceMerkleRequest {
    /**
     * Namespace identifier.
     * @type {string}
     * @memberof NamespaceRoutesApiGetNamespaceMerkle
     */
    readonly namespaceId: string
}

/**
 * Request parameters for getNamespacesNames operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiGetNamespacesNamesRequest
 */
export interface NamespaceRoutesApiGetNamespacesNamesRequest {
    /**
     * 
     * @type {NamespaceIds}
     * @memberof NamespaceRoutesApiGetNamespacesNames
     */
    readonly namespaceIds: NamespaceIds
}

/**
 * Request parameters for searchNamespaces operation in NamespaceRoutesApi.
 * @export
 * @interface NamespaceRoutesApiSearchNamespacesRequest
 */
export interface NamespaceRoutesApiSearchNamespacesRequest {
    /**
     * Filter by owner address.
     * @type {string}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly ownerAddress?: string

    /**
     * Filter by registration type.
     * @type {NamespaceRegistrationTypeEnum}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly registrationType?: NamespaceRegistrationTypeEnum

    /**
     * Filter by root namespace.
     * @type {string}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly level0?: string

    /**
     * Filter by alias type.
     * @type {AliasTypeEnum}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly aliasType?: AliasTypeEnum

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof NamespaceRoutesApiSearchNamespaces
     */
    readonly order?: Order
}

/**
 * NamespaceRoutesApi - object-oriented interface
 * @export
 * @class NamespaceRoutesApi
 * @extends {BaseAPI}
 */
export class NamespaceRoutesApi extends BaseAPI {
    /**
     * Returns friendly names for accounts.
     * @summary Get readable names for a set of accountIds
     * @param {NamespaceRoutesApiGetAccountsNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public getAccountsNames(requestParameters: NamespaceRoutesApiGetAccountsNamesRequest, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).getAccountsNames(requestParameters.addresses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns friendly names for mosaics.
     * @summary Get readable names for a set of mosaics
     * @param {NamespaceRoutesApiGetMosaicsNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public getMosaicsNames(requestParameters: NamespaceRoutesApiGetMosaicsNamesRequest, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).getMosaicsNames(requestParameters.mosaicIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the namespace for a given namespace identifier.
     * @summary Get namespace information
     * @param {NamespaceRoutesApiGetNamespaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public getNamespace(requestParameters: NamespaceRoutesApiGetNamespaceRequest, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).getNamespace(requestParameters.namespaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the namespace merkle for a given namespace identifier.
     * @summary Get namespace merkle information
     * @param {NamespaceRoutesApiGetNamespaceMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public getNamespaceMerkle(requestParameters: NamespaceRoutesApiGetNamespaceMerkleRequest, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).getNamespaceMerkle(requestParameters.namespaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns friendly names for namespaces.
     * @summary Get readable names for a set of namespaces
     * @param {NamespaceRoutesApiGetNamespacesNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public getNamespacesNames(requestParameters: NamespaceRoutesApiGetNamespacesNamesRequest, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).getNamespacesNames(requestParameters.namespaceIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of namespaces.
     * @summary Search namespaces
     * @param {NamespaceRoutesApiSearchNamespacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    public searchNamespaces(requestParameters: NamespaceRoutesApiSearchNamespacesRequest = {}, options?: AxiosRequestConfig) {
        return NamespaceRoutesApiFp(this.configuration).searchNamespaces(requestParameters.ownerAddress, requestParameters.registrationType, requestParameters.level0, requestParameters.aliasType, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkRoutesApi - axios parameter creator
 * @export
 */
export const NetworkRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkProperties: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json). 
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRentalFees: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network/fees/rental`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFees: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network/fees/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkRoutesApi - functional programming interface
 * @export
 */
export const NetworkRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkProperties(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkConfigurationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkProperties(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkTypeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json). 
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRentalFees(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RentalFeesDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRentalFees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionFees(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionFeesDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionFees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkRoutesApi - factory interface
 * @export
 */
export const NetworkRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkRoutesApiFp(configuration)
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkProperties(options?: any): AxiosPromise<NetworkConfigurationDTO> {
            return localVarFp.getNetworkProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkType(options?: any): AxiosPromise<NetworkTypeDTO> {
            return localVarFp.getNetworkType(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json). 
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRentalFees(options?: any): AxiosPromise<RentalFeesDTO> {
            return localVarFp.getRentalFees(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFees(options?: any): AxiosPromise<TransactionFeesDTO> {
            return localVarFp.getTransactionFees(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkRoutesApi - object-oriented interface
 * @export
 * @class NetworkRoutesApi
 * @extends {BaseAPI}
 */
export class NetworkRoutesApi extends BaseAPI {
    /**
     * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
     * @summary Get the network properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    public getNetworkProperties(options?: AxiosRequestConfig) {
        return NetworkRoutesApiFp(this.configuration).getNetworkProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current network type.
     * @summary Get the current network type of the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    public getNetworkType(options?: AxiosRequestConfig) {
        return NetworkRoutesApiFp(this.configuration).getNetworkType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json). 
     * @summary Get rental fees information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    public getRentalFees(options?: AxiosRequestConfig) {
        return NetworkRoutesApiFp(this.configuration).getRentalFees(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance. 
     * @summary Get transaction fees information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    public getTransactionFees(options?: AxiosRequestConfig) {
        return NetworkRoutesApiFp(this.configuration).getTransactionFees(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodeRoutesApi - axios parameter creator
 * @export
 */
export const NodeRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodePeers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/peers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStorage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeTime: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/node/unlockedaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeRoutesApi - functional programming interface
 * @export
 */
export const NodeRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeHealthInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodePeers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodePeers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeStorage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeStorage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeTime(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeTimeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeTime(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlockedAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnlockedAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlockedAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodeRoutesApi - factory interface
 * @export
 */
export const NodeRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeRoutesApiFp(configuration)
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeHealth(options?: any): AxiosPromise<NodeHealthInfoDTO> {
            return localVarFp.getNodeHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options?: any): AxiosPromise<NodeInfoDTO> {
            return localVarFp.getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodePeers(options?: any): AxiosPromise<Array<NodeInfoDTO>> {
            return localVarFp.getNodePeers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStorage(options?: any): AxiosPromise<StorageInfoDTO> {
            return localVarFp.getNodeStorage(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeTime(options?: any): AxiosPromise<NodeTimeDTO> {
            return localVarFp.getNodeTime(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<ServerInfoDTO> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedAccount(options?: any): AxiosPromise<UnlockedAccountDTO> {
            return localVarFp.getUnlockedAccount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeRoutesApi - object-oriented interface
 * @export
 * @class NodeRoutesApi
 * @extends {BaseAPI}
 */
export class NodeRoutesApi extends BaseAPI {
    /**
     * Supplies information regarding the connection and services status.
     * @summary Get the node health information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getNodeHealth(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getNodeHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supplies additional information about the application running on a node.
     * @summary Get the node information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getNodeInfo(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the list of peers visible by the node.
     * @summary Get peers information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getNodePeers(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getNodePeers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns storage information about the node.
     * @summary Get the storage information of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getNodeStorage(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getNodeStorage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the node time at the moment the reply was sent and received.
     * @summary Get the node time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getNodeTime(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getNodeTime(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the version of the running catapult-rest component.
     * @summary Get the version of the running REST component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns array of unlocked account public keys.
     * @summary Get the unlocked harvesting account public keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    public getUnlockedAccount(options?: AxiosRequestConfig) {
        return NodeRoutesApiFp(this.configuration).getUnlockedAccount(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReceiptRoutesApi - axios parameter creator
 * @export
 */
export const ReceiptRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAddressResolutionStatements: async (height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/resolutions/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicResolutionStatements: async (height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/resolutions/mosaic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReceipts: async (height?: string, fromHeight?: string, toHeight?: string, receiptType?: Array<ReceiptTypeEnum>, recipientAddress?: string, senderAddress?: string, targetAddress?: string, artifactId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/statements/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }

            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }

            if (receiptType) {
                localVarQueryParameter['receiptType'] = receiptType;
            }

            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }

            if (senderAddress !== undefined) {
                localVarQueryParameter['senderAddress'] = senderAddress;
            }

            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }

            if (artifactId !== undefined) {
                localVarQueryParameter['artifactId'] = artifactId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReceiptRoutesApi - functional programming interface
 * @export
 */
export const ReceiptRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReceiptRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAddressResolutionStatements(height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolutionStatementPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaicResolutionStatements(height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolutionStatementPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchReceipts(height?: string, fromHeight?: string, toHeight?: string, receiptType?: Array<ReceiptTypeEnum>, recipientAddress?: string, senderAddress?: string, targetAddress?: string, artifactId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionStatementPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReceiptRoutesApi - factory interface
 * @export
 */
export const ReceiptRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReceiptRoutesApiFp(configuration)
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAddressResolutionStatements(height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<ResolutionStatementPage> {
            return localVarFp.searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicResolutionStatements(height?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<ResolutionStatementPage> {
            return localVarFp.searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReceipts(height?: string, fromHeight?: string, toHeight?: string, receiptType?: Array<ReceiptTypeEnum>, recipientAddress?: string, senderAddress?: string, targetAddress?: string, artifactId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<TransactionStatementPage> {
            return localVarFp.searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchAddressResolutionStatements operation in ReceiptRoutesApi.
 * @export
 * @interface ReceiptRoutesApiSearchAddressResolutionStatementsRequest
 */
export interface ReceiptRoutesApiSearchAddressResolutionStatementsRequest {
    /**
     * Filter by block height.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchAddressResolutionStatements
     */
    readonly height?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchAddressResolutionStatements
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchAddressResolutionStatements
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof ReceiptRoutesApiSearchAddressResolutionStatements
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof ReceiptRoutesApiSearchAddressResolutionStatements
     */
    readonly order?: Order
}

/**
 * Request parameters for searchMosaicResolutionStatements operation in ReceiptRoutesApi.
 * @export
 * @interface ReceiptRoutesApiSearchMosaicResolutionStatementsRequest
 */
export interface ReceiptRoutesApiSearchMosaicResolutionStatementsRequest {
    /**
     * Filter by block height.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchMosaicResolutionStatements
     */
    readonly height?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchMosaicResolutionStatements
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchMosaicResolutionStatements
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof ReceiptRoutesApiSearchMosaicResolutionStatements
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof ReceiptRoutesApiSearchMosaicResolutionStatements
     */
    readonly order?: Order
}

/**
 * Request parameters for searchReceipts operation in ReceiptRoutesApi.
 * @export
 * @interface ReceiptRoutesApiSearchReceiptsRequest
 */
export interface ReceiptRoutesApiSearchReceiptsRequest {
    /**
     * Filter by block height.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly height?: string

    /**
     * Only blocks with height greater or equal than this one are returned.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly fromHeight?: string

    /**
     * Only blocks with height smaller or equal than this one are returned.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly toHeight?: string

    /**
     * Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;. 
     * @type {Array<ReceiptTypeEnum>}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly receiptType?: Array<ReceiptTypeEnum>

    /**
     * Filter by address of the account receiving the transaction.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly recipientAddress?: string

    /**
     * Filter by address sending mosaics.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly senderAddress?: string

    /**
     * Filter by target address.
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly targetAddress?: string

    /**
     * Mosaic or namespace identifier
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly artifactId?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof ReceiptRoutesApiSearchReceipts
     */
    readonly order?: Order
}

/**
 * ReceiptRoutesApi - object-oriented interface
 * @export
 * @class ReceiptRoutesApi
 * @extends {BaseAPI}
 */
export class ReceiptRoutesApi extends BaseAPI {
    /**
     * Gets an array of address resolution statements.
     * @summary Get receipts address resolution statements
     * @param {ReceiptRoutesApiSearchAddressResolutionStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    public searchAddressResolutionStatements(requestParameters: ReceiptRoutesApiSearchAddressResolutionStatementsRequest = {}, options?: AxiosRequestConfig) {
        return ReceiptRoutesApiFp(this.configuration).searchAddressResolutionStatements(requestParameters.height, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of mosaic resolution statements.
     * @summary Get receipts mosaic resolution statements
     * @param {ReceiptRoutesApiSearchMosaicResolutionStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    public searchMosaicResolutionStatements(requestParameters: ReceiptRoutesApiSearchMosaicResolutionStatementsRequest = {}, options?: AxiosRequestConfig) {
        return ReceiptRoutesApiFp(this.configuration).searchMosaicResolutionStatements(requestParameters.height, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets an array of transaction statements.
     * @summary Search transaction statements
     * @param {ReceiptRoutesApiSearchReceiptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    public searchReceipts(requestParameters: ReceiptRoutesApiSearchReceiptsRequest = {}, options?: AxiosRequestConfig) {
        return ReceiptRoutesApiFp(this.configuration).searchReceipts(requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.receiptType, requestParameters.recipientAddress, requestParameters.senderAddress, requestParameters.targetAddress, requestParameters.artifactId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RestrictionAccountRoutesApi - axios parameter creator
 * @export
 */
export const RestrictionAccountRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictions: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountRestrictions', 'address', address)
            const localVarPath = `/restrictions/account/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictionsMerkle: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountRestrictionsMerkle', 'address', address)
            const localVarPath = `/restrictions/account/{address}/merkle`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccountRestrictions: async (address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/restrictions/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestrictionAccountRoutesApi - functional programming interface
 * @export
 */
export const RestrictionAccountRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestrictionAccountRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRestrictions(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRestrictionsInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRestrictions(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRestrictionsMerkle(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRestrictionsMerkle(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccountRestrictions(address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRestrictionsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RestrictionAccountRoutesApi - factory interface
 * @export
 */
export const RestrictionAccountRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestrictionAccountRoutesApiFp(configuration)
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictions(address: string, options?: any): AxiosPromise<AccountRestrictionsInfoDTO> {
            return localVarFp.getAccountRestrictions(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictionsMerkle(address: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getAccountRestrictionsMerkle(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccountRestrictions(address?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<AccountRestrictionsPage> {
            return localVarFp.searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAccountRestrictions operation in RestrictionAccountRoutesApi.
 * @export
 * @interface RestrictionAccountRoutesApiGetAccountRestrictionsRequest
 */
export interface RestrictionAccountRoutesApiGetAccountRestrictionsRequest {
    /**
     * Account address.
     * @type {string}
     * @memberof RestrictionAccountRoutesApiGetAccountRestrictions
     */
    readonly address: string
}

/**
 * Request parameters for getAccountRestrictionsMerkle operation in RestrictionAccountRoutesApi.
 * @export
 * @interface RestrictionAccountRoutesApiGetAccountRestrictionsMerkleRequest
 */
export interface RestrictionAccountRoutesApiGetAccountRestrictionsMerkleRequest {
    /**
     * Account address.
     * @type {string}
     * @memberof RestrictionAccountRoutesApiGetAccountRestrictionsMerkle
     */
    readonly address: string
}

/**
 * Request parameters for searchAccountRestrictions operation in RestrictionAccountRoutesApi.
 * @export
 * @interface RestrictionAccountRoutesApiSearchAccountRestrictionsRequest
 */
export interface RestrictionAccountRoutesApiSearchAccountRestrictionsRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof RestrictionAccountRoutesApiSearchAccountRestrictions
     */
    readonly address?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof RestrictionAccountRoutesApiSearchAccountRestrictions
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof RestrictionAccountRoutesApiSearchAccountRestrictions
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof RestrictionAccountRoutesApiSearchAccountRestrictions
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof RestrictionAccountRoutesApiSearchAccountRestrictions
     */
    readonly order?: Order
}

/**
 * RestrictionAccountRoutesApi - object-oriented interface
 * @export
 * @class RestrictionAccountRoutesApi
 * @extends {BaseAPI}
 */
export class RestrictionAccountRoutesApi extends BaseAPI {
    /**
     * Returns the account restrictions for a given address.
     * @summary Get the account restrictions
     * @param {RestrictionAccountRoutesApiGetAccountRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    public getAccountRestrictions(requestParameters: RestrictionAccountRoutesApiGetAccountRestrictionsRequest, options?: AxiosRequestConfig) {
        return RestrictionAccountRoutesApiFp(this.configuration).getAccountRestrictions(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the account restrictions merkle for a given address.
     * @summary Get the account restrictions merkle
     * @param {RestrictionAccountRoutesApiGetAccountRestrictionsMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    public getAccountRestrictionsMerkle(requestParameters: RestrictionAccountRoutesApiGetAccountRestrictionsMerkleRequest, options?: AxiosRequestConfig) {
        return RestrictionAccountRoutesApiFp(this.configuration).getAccountRestrictionsMerkle(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of account restrictions.
     * @summary Search account restrictions
     * @param {RestrictionAccountRoutesApiSearchAccountRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    public searchAccountRestrictions(requestParameters: RestrictionAccountRoutesApiSearchAccountRestrictionsRequest = {}, options?: AxiosRequestConfig) {
        return RestrictionAccountRoutesApiFp(this.configuration).searchAccountRestrictions(requestParameters.address, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RestrictionMosaicRoutesApi - axios parameter creator
 * @export
 */
export const RestrictionMosaicRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictions: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMosaicRestrictions', 'compositeHash', compositeHash)
            const localVarPath = `/restrictions/mosaic/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictionsMerkle: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMosaicRestrictionsMerkle', 'compositeHash', compositeHash)
            const localVarPath = `/restrictions/mosaic/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicRestrictions: async (mosaicId?: string, entryType?: MosaicRestrictionEntryTypeEnum, targetAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/restrictions/mosaic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mosaicId !== undefined) {
                localVarQueryParameter['mosaicId'] = mosaicId;
            }

            if (entryType !== undefined) {
                localVarQueryParameter['entryType'] = entryType;
            }

            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RestrictionMosaicRoutesApi - functional programming interface
 * @export
 */
export const RestrictionMosaicRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RestrictionMosaicRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicRestrictions(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MosaicRestrictionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicRestrictions(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicRestrictionsMerkle(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicRestrictionsMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaicRestrictions(mosaicId?: string, entryType?: MosaicRestrictionEntryTypeEnum, targetAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MosaicRestrictionsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RestrictionMosaicRoutesApi - factory interface
 * @export
 */
export const RestrictionMosaicRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RestrictionMosaicRoutesApiFp(configuration)
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictions(compositeHash: string, options?: any): AxiosPromise<MosaicRestrictionDTO> {
            return localVarFp.getMosaicRestrictions(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictionsMerkle(compositeHash: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getMosaicRestrictionsMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicRestrictions(mosaicId?: string, entryType?: MosaicRestrictionEntryTypeEnum, targetAddress?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<MosaicRestrictionsPage> {
            return localVarFp.searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMosaicRestrictions operation in RestrictionMosaicRoutesApi.
 * @export
 * @interface RestrictionMosaicRoutesApiGetMosaicRestrictionsRequest
 */
export interface RestrictionMosaicRoutesApiGetMosaicRestrictionsRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof RestrictionMosaicRoutesApiGetMosaicRestrictions
     */
    readonly compositeHash: string
}

/**
 * Request parameters for getMosaicRestrictionsMerkle operation in RestrictionMosaicRoutesApi.
 * @export
 * @interface RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkleRequest
 */
export interface RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkleRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkle
     */
    readonly compositeHash: string
}

/**
 * Request parameters for searchMosaicRestrictions operation in RestrictionMosaicRoutesApi.
 * @export
 * @interface RestrictionMosaicRoutesApiSearchMosaicRestrictionsRequest
 */
export interface RestrictionMosaicRoutesApiSearchMosaicRestrictionsRequest {
    /**
     * Filter by mosaic identifier.
     * @type {string}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly mosaicId?: string

    /**
     * Filter by entry type.
     * @type {MosaicRestrictionEntryTypeEnum}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly entryType?: MosaicRestrictionEntryTypeEnum

    /**
     * Filter by target address.
     * @type {string}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly targetAddress?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof RestrictionMosaicRoutesApiSearchMosaicRestrictions
     */
    readonly order?: Order
}

/**
 * RestrictionMosaicRoutesApi - object-oriented interface
 * @export
 * @class RestrictionMosaicRoutesApi
 * @extends {BaseAPI}
 */
export class RestrictionMosaicRoutesApi extends BaseAPI {
    /**
     * Returns the mosaic restrictions for a composite hash.
     * @summary Get the mosaic restrictions
     * @param {RestrictionMosaicRoutesApiGetMosaicRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    public getMosaicRestrictions(requestParameters: RestrictionMosaicRoutesApiGetMosaicRestrictionsRequest, options?: AxiosRequestConfig) {
        return RestrictionMosaicRoutesApiFp(this.configuration).getMosaicRestrictions(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the mosaic restrictions merkle for a given composite hash.
     * @summary Get the mosaic restrictions merkle
     * @param {RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    public getMosaicRestrictionsMerkle(requestParameters: RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkleRequest, options?: AxiosRequestConfig) {
        return RestrictionMosaicRoutesApiFp(this.configuration).getMosaicRestrictionsMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of mosaic restrictions.
     * @summary Search mosaic restrictions
     * @param {RestrictionMosaicRoutesApiSearchMosaicRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    public searchMosaicRestrictions(requestParameters: RestrictionMosaicRoutesApiSearchMosaicRestrictionsRequest = {}, options?: AxiosRequestConfig) {
        return RestrictionMosaicRoutesApiFp(this.configuration).searchMosaicRestrictions(requestParameters.mosaicId, requestParameters.entryType, requestParameters.targetAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecretLockRoutesApi - axios parameter creator
 * @export
 */
export const SecretLockRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLock: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getSecretLock', 'compositeHash', compositeHash)
            const localVarPath = `/lock/secret/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLockMerkle: async (compositeHash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getSecretLockMerkle', 'compositeHash', compositeHash)
            const localVarPath = `/lock/secret/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecretLock: async (address?: string, secret?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lock/secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretLockRoutesApi - functional programming interface
 * @export
 */
export const SecretLockRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretLockRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecretLock(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretLockInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecretLock(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecretLockMerkle(compositeHash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerkleStateInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecretLockMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSecretLock(address?: string, secret?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretLockPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecretLockRoutesApi - factory interface
 * @export
 */
export const SecretLockRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretLockRoutesApiFp(configuration)
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLock(compositeHash: string, options?: any): AxiosPromise<SecretLockInfoDTO> {
            return localVarFp.getSecretLock(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLockMerkle(compositeHash: string, options?: any): AxiosPromise<MerkleStateInfoDTO> {
            return localVarFp.getSecretLockMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecretLock(address?: string, secret?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<SecretLockPage> {
            return localVarFp.searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSecretLock operation in SecretLockRoutesApi.
 * @export
 * @interface SecretLockRoutesApiGetSecretLockRequest
 */
export interface SecretLockRoutesApiGetSecretLockRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof SecretLockRoutesApiGetSecretLock
     */
    readonly compositeHash: string
}

/**
 * Request parameters for getSecretLockMerkle operation in SecretLockRoutesApi.
 * @export
 * @interface SecretLockRoutesApiGetSecretLockMerkleRequest
 */
export interface SecretLockRoutesApiGetSecretLockMerkleRequest {
    /**
     * Filter by composite hash.
     * @type {string}
     * @memberof SecretLockRoutesApiGetSecretLockMerkle
     */
    readonly compositeHash: string
}

/**
 * Request parameters for searchSecretLock operation in SecretLockRoutesApi.
 * @export
 * @interface SecretLockRoutesApiSearchSecretLockRequest
 */
export interface SecretLockRoutesApiSearchSecretLockRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly address?: string

    /**
     * Filter by secret.
     * @type {string}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly secret?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof SecretLockRoutesApiSearchSecretLock
     */
    readonly order?: Order
}

/**
 * SecretLockRoutesApi - object-oriented interface
 * @export
 * @class SecretLockRoutesApi
 * @extends {BaseAPI}
 */
export class SecretLockRoutesApi extends BaseAPI {
    /**
     * Gets the hash lock for a given composite hash.
     * @summary Get secret lock information
     * @param {SecretLockRoutesApiGetSecretLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    public getSecretLock(requestParameters: SecretLockRoutesApiGetSecretLockRequest, options?: AxiosRequestConfig) {
        return SecretLockRoutesApiFp(this.configuration).getSecretLock(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the hash lock merkle for a given composite hash.
     * @summary Get secret lock merkle information
     * @param {SecretLockRoutesApiGetSecretLockMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    public getSecretLockMerkle(requestParameters: SecretLockRoutesApiGetSecretLockMerkleRequest, options?: AxiosRequestConfig) {
        return SecretLockRoutesApiFp(this.configuration).getSecretLockMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of secret locks.
     * @summary Search secret lock entries
     * @param {SecretLockRoutesApiSearchSecretLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    public searchSecretLock(requestParameters: SecretLockRoutesApiSearchSecretLockRequest = {}, options?: AxiosRequestConfig) {
        return SecretLockRoutesApiFp(this.configuration).searchSecretLock(requestParameters.address, requestParameters.secret, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionRoutesApi - axios parameter creator
 * @export
 */
export const TransactionRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceCosignatureTransaction: async (cosignature: Cosignature, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cosignature' is not null or undefined
            assertParamExists('announceCosignatureTransaction', 'cosignature', cosignature)
            const localVarPath = `/transactions/cosignature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cosignature, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcePartialTransaction: async (transactionPayload: TransactionPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionPayload' is not null or undefined
            assertParamExists('announcePartialTransaction', 'transactionPayload', transactionPayload)
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceTransaction: async (transactionPayload: TransactionPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionPayload' is not null or undefined
            assertParamExists('announceTransaction', 'transactionPayload', transactionPayload)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionPayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getConfirmedTransaction', 'transactionId', transactionId)
            const localVarPath = `/transactions/confirmed/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransactions: async (transactionIds: TransactionIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getConfirmedTransactions', 'transactionIds', transactionIds)
            const localVarPath = `/transactions/confirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getPartialTransaction', 'transactionId', transactionId)
            const localVarPath = `/transactions/partial/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransactions: async (transactionIds: TransactionIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getPartialTransactions', 'transactionIds', transactionIds)
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getUnconfirmedTransaction', 'transactionId', transactionId)
            const localVarPath = `/transactions/unconfirmed/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransactions: async (transactionIds: TransactionIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getUnconfirmedTransactions', 'transactionIds', transactionIds)
            const localVarPath = `/transactions/unconfirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfirmedTransactions: async (address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/confirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }

            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }

            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }

            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }

            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }

            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartialTransactions: async (address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }

            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }

            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }

            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }

            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }

            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnconfirmedTransactions: async (address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/unconfirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }

            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }

            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }

            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }

            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }

            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionRoutesApi - functional programming interface
 * @export
 */
export const TransactionRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announceCosignatureTransaction(cosignature: Cosignature, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnounceTransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announceCosignatureTransaction(cosignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcePartialTransaction(transactionPayload: TransactionPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnounceTransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcePartialTransaction(transactionPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announceTransaction(transactionPayload: TransactionPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnounceTransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announceTransaction(transactionPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfirmedTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfirmedTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfirmedTransactions(transactionIds: TransactionIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfirmedTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartialTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartialTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartialTransactions(transactionIds: TransactionIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartialTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnconfirmedTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionInfoDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnconfirmedTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnconfirmedTransactions(transactionIds: TransactionIds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnconfirmedTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchConfirmedTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPartialTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUnconfirmedTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionRoutesApi - factory interface
 * @export
 */
export const TransactionRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionRoutesApiFp(configuration)
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceCosignatureTransaction(cosignature: Cosignature, options?: any): AxiosPromise<AnnounceTransactionInfoDTO> {
            return localVarFp.announceCosignatureTransaction(cosignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcePartialTransaction(transactionPayload: TransactionPayload, options?: any): AxiosPromise<AnnounceTransactionInfoDTO> {
            return localVarFp.announcePartialTransaction(transactionPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceTransaction(transactionPayload: TransactionPayload, options?: any): AxiosPromise<AnnounceTransactionInfoDTO> {
            return localVarFp.announceTransaction(transactionPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransaction(transactionId: string, options?: any): AxiosPromise<TransactionInfoDTO> {
            return localVarFp.getConfirmedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransactions(transactionIds: TransactionIds, options?: any): AxiosPromise<Array<TransactionInfoDTO>> {
            return localVarFp.getConfirmedTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransaction(transactionId: string, options?: any): AxiosPromise<TransactionInfoDTO> {
            return localVarFp.getPartialTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransactions(transactionIds: TransactionIds, options?: any): AxiosPromise<Array<TransactionInfoDTO>> {
            return localVarFp.getPartialTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransaction(transactionId: string, options?: any): AxiosPromise<TransactionInfoDTO> {
            return localVarFp.getUnconfirmedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransactions(transactionIds: TransactionIds, options?: any): AxiosPromise<Array<TransactionInfoDTO>> {
            return localVarFp.getUnconfirmedTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfirmedTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<TransactionPage> {
            return localVarFp.searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartialTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<TransactionPage> {
            return localVarFp.searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnconfirmedTransactions(address?: string, recipientAddress?: string, signerPublicKey?: string, height?: string, fromHeight?: string, toHeight?: string, fromTransferAmount?: string, toTransferAmount?: string, type?: Array<TransactionTypeEnum>, embedded?: boolean, transferMosaicId?: string, pageSize?: number, pageNumber?: number, offset?: string, order?: Order, options?: any): AxiosPromise<TransactionPage> {
            return localVarFp.searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for announceCosignatureTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiAnnounceCosignatureTransactionRequest
 */
export interface TransactionRoutesApiAnnounceCosignatureTransactionRequest {
    /**
     * 
     * @type {Cosignature}
     * @memberof TransactionRoutesApiAnnounceCosignatureTransaction
     */
    readonly cosignature: Cosignature
}

/**
 * Request parameters for announcePartialTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiAnnouncePartialTransactionRequest
 */
export interface TransactionRoutesApiAnnouncePartialTransactionRequest {
    /**
     * 
     * @type {TransactionPayload}
     * @memberof TransactionRoutesApiAnnouncePartialTransaction
     */
    readonly transactionPayload: TransactionPayload
}

/**
 * Request parameters for announceTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiAnnounceTransactionRequest
 */
export interface TransactionRoutesApiAnnounceTransactionRequest {
    /**
     * 
     * @type {TransactionPayload}
     * @memberof TransactionRoutesApiAnnounceTransaction
     */
    readonly transactionPayload: TransactionPayload
}

/**
 * Request parameters for getConfirmedTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetConfirmedTransactionRequest
 */
export interface TransactionRoutesApiGetConfirmedTransactionRequest {
    /**
     * Transaction id or hash.
     * @type {string}
     * @memberof TransactionRoutesApiGetConfirmedTransaction
     */
    readonly transactionId: string
}

/**
 * Request parameters for getConfirmedTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetConfirmedTransactionsRequest
 */
export interface TransactionRoutesApiGetConfirmedTransactionsRequest {
    /**
     * 
     * @type {TransactionIds}
     * @memberof TransactionRoutesApiGetConfirmedTransactions
     */
    readonly transactionIds: TransactionIds
}

/**
 * Request parameters for getPartialTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetPartialTransactionRequest
 */
export interface TransactionRoutesApiGetPartialTransactionRequest {
    /**
     * Transaction id or hash.
     * @type {string}
     * @memberof TransactionRoutesApiGetPartialTransaction
     */
    readonly transactionId: string
}

/**
 * Request parameters for getPartialTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetPartialTransactionsRequest
 */
export interface TransactionRoutesApiGetPartialTransactionsRequest {
    /**
     * 
     * @type {TransactionIds}
     * @memberof TransactionRoutesApiGetPartialTransactions
     */
    readonly transactionIds: TransactionIds
}

/**
 * Request parameters for getUnconfirmedTransaction operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetUnconfirmedTransactionRequest
 */
export interface TransactionRoutesApiGetUnconfirmedTransactionRequest {
    /**
     * Transaction id or hash.
     * @type {string}
     * @memberof TransactionRoutesApiGetUnconfirmedTransaction
     */
    readonly transactionId: string
}

/**
 * Request parameters for getUnconfirmedTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiGetUnconfirmedTransactionsRequest
 */
export interface TransactionRoutesApiGetUnconfirmedTransactionsRequest {
    /**
     * 
     * @type {TransactionIds}
     * @memberof TransactionRoutesApiGetUnconfirmedTransactions
     */
    readonly transactionIds: TransactionIds
}

/**
 * Request parameters for searchConfirmedTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiSearchConfirmedTransactionsRequest
 */
export interface TransactionRoutesApiSearchConfirmedTransactionsRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly address?: string

    /**
     * Filter by address of the account receiving the transaction.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly recipientAddress?: string

    /**
     * Filter by public key of the account signing the entity.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly signerPublicKey?: string

    /**
     * Filter by block height.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly height?: string

    /**
     * Only blocks with height greater or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly fromHeight?: string

    /**
     * Only blocks with height smaller or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly toHeight?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly fromTransferAmount?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly toTransferAmount?: string

    /**
     * Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
     * @type {Array<TransactionTypeEnum>}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly type?: Array<TransactionTypeEnum>

    /**
     * When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
     * @type {boolean}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly embedded?: boolean

    /**
     * Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly transferMosaicId?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof TransactionRoutesApiSearchConfirmedTransactions
     */
    readonly order?: Order
}

/**
 * Request parameters for searchPartialTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiSearchPartialTransactionsRequest
 */
export interface TransactionRoutesApiSearchPartialTransactionsRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly address?: string

    /**
     * Filter by address of the account receiving the transaction.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly recipientAddress?: string

    /**
     * Filter by public key of the account signing the entity.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly signerPublicKey?: string

    /**
     * Filter by block height.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly height?: string

    /**
     * Only blocks with height greater or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly fromHeight?: string

    /**
     * Only blocks with height smaller or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly toHeight?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly fromTransferAmount?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly toTransferAmount?: string

    /**
     * Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
     * @type {Array<TransactionTypeEnum>}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly type?: Array<TransactionTypeEnum>

    /**
     * When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
     * @type {boolean}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly embedded?: boolean

    /**
     * Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly transferMosaicId?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof TransactionRoutesApiSearchPartialTransactions
     */
    readonly order?: Order
}

/**
 * Request parameters for searchUnconfirmedTransactions operation in TransactionRoutesApi.
 * @export
 * @interface TransactionRoutesApiSearchUnconfirmedTransactionsRequest
 */
export interface TransactionRoutesApiSearchUnconfirmedTransactionsRequest {
    /**
     * Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly address?: string

    /**
     * Filter by address of the account receiving the transaction.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly recipientAddress?: string

    /**
     * Filter by public key of the account signing the entity.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly signerPublicKey?: string

    /**
     * Filter by block height.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly height?: string

    /**
     * Only blocks with height greater or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly fromHeight?: string

    /**
     * Only blocks with height smaller or equal than this one are returned.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly toHeight?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly fromTransferAmount?: string

    /**
     * Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly toTransferAmount?: string

    /**
     * Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;. 
     * @type {Array<TransactionTypeEnum>}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly type?: Array<TransactionTypeEnum>

    /**
     * When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead. 
     * @type {boolean}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly embedded?: boolean

    /**
     * Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly transferMosaicId?: string

    /**
     * Select the number of entries to return.
     * @type {number}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly pageSize?: number

    /**
     * Filter by page number.
     * @type {number}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly pageNumber?: number

    /**
     * Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned. 
     * @type {string}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly offset?: string

    /**
     * Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id. 
     * @type {Order}
     * @memberof TransactionRoutesApiSearchUnconfirmedTransactions
     */
    readonly order?: Order
}

/**
 * TransactionRoutesApi - object-oriented interface
 * @export
 * @class TransactionRoutesApi
 * @extends {BaseAPI}
 */
export class TransactionRoutesApi extends BaseAPI {
    /**
     * Announces a cosignature transaction to the network.
     * @summary Announce a cosignature transaction
     * @param {TransactionRoutesApiAnnounceCosignatureTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public announceCosignatureTransaction(requestParameters: TransactionRoutesApiAnnounceCosignatureTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).announceCosignatureTransaction(requestParameters.cosignature, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Announces an aggregate bonded transaction to the network.
     * @summary Announce an aggregate bonded transaction
     * @param {TransactionRoutesApiAnnouncePartialTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public announcePartialTransaction(requestParameters: TransactionRoutesApiAnnouncePartialTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).announcePartialTransaction(requestParameters.transactionPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
     * @summary Announce a new transaction
     * @param {TransactionRoutesApiAnnounceTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public announceTransaction(requestParameters: TransactionRoutesApiAnnounceTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).announceTransaction(requestParameters.transactionPayload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * @summary Get confirmed transaction information
     * @param {TransactionRoutesApiGetConfirmedTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getConfirmedTransaction(requestParameters: TransactionRoutesApiGetConfirmedTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getConfirmedTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * @summary Get confirmed trasactions information
     * @param {TransactionRoutesApiGetConfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getConfirmedTransactions(requestParameters: TransactionRoutesApiGetConfirmedTransactionsRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getConfirmedTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns partial transaction information given a transactionId or hash.
     * @summary Get partial transaction information
     * @param {TransactionRoutesApiGetPartialTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getPartialTransaction(requestParameters: TransactionRoutesApiGetPartialTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getPartialTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns partial transactions information for a given array of transactionIds.
     * @summary Get partial trasactions information
     * @param {TransactionRoutesApiGetPartialTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getPartialTransactions(requestParameters: TransactionRoutesApiGetPartialTransactionsRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getPartialTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * @summary Get unconfirmed transaction information
     * @param {TransactionRoutesApiGetUnconfirmedTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getUnconfirmedTransaction(requestParameters: TransactionRoutesApiGetUnconfirmedTransactionRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getUnconfirmedTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * @summary Get unconfirmed trasactions information
     * @param {TransactionRoutesApiGetUnconfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public getUnconfirmedTransactions(requestParameters: TransactionRoutesApiGetUnconfirmedTransactionsRequest, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).getUnconfirmedTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
     * @summary Search confirmed transactions
     * @param {TransactionRoutesApiSearchConfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public searchConfirmedTransactions(requestParameters: TransactionRoutesApiSearchConfirmedTransactionsRequest = {}, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).searchConfirmedTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of partial transactions.
     * @summary Search partial transactions
     * @param {TransactionRoutesApiSearchPartialTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public searchPartialTransactions(requestParameters: TransactionRoutesApiSearchPartialTransactionsRequest = {}, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).searchPartialTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of unconfirmed transactions.
     * @summary Search unconfirmed transactions
     * @param {TransactionRoutesApiSearchUnconfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    public searchUnconfirmedTransactions(requestParameters: TransactionRoutesApiSearchUnconfirmedTransactionsRequest = {}, options?: AxiosRequestConfig) {
        return TransactionRoutesApiFp(this.configuration).searchUnconfirmedTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionStatusRoutesApi - axios parameter creator
 * @export
 */
export const TransactionStatusRoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatus: async (hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTransactionStatus', 'hash', hash)
            const localVarPath = `/transactionStatus/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses: async (transactionHashes: TransactionHashes, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionHashes' is not null or undefined
            assertParamExists('getTransactionStatuses', 'transactionHashes', transactionHashes)
            const localVarPath = `/transactionStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionHashes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionStatusRoutesApi - functional programming interface
 * @export
 */
export const TransactionStatusRoutesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionStatusRoutesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionStatus(hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionStatusDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionStatus(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionStatuses(transactionHashes: TransactionHashes, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionStatusDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionStatuses(transactionHashes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionStatusRoutesApi - factory interface
 * @export
 */
export const TransactionStatusRoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionStatusRoutesApiFp(configuration)
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatus(hash: string, options?: any): AxiosPromise<TransactionStatusDTO> {
            return localVarFp.getTransactionStatus(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses(transactionHashes: TransactionHashes, options?: any): AxiosPromise<Array<TransactionStatusDTO>> {
            return localVarFp.getTransactionStatuses(transactionHashes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTransactionStatus operation in TransactionStatusRoutesApi.
 * @export
 * @interface TransactionStatusRoutesApiGetTransactionStatusRequest
 */
export interface TransactionStatusRoutesApiGetTransactionStatusRequest {
    /**
     * Transaction hash.
     * @type {string}
     * @memberof TransactionStatusRoutesApiGetTransactionStatus
     */
    readonly hash: string
}

/**
 * Request parameters for getTransactionStatuses operation in TransactionStatusRoutesApi.
 * @export
 * @interface TransactionStatusRoutesApiGetTransactionStatusesRequest
 */
export interface TransactionStatusRoutesApiGetTransactionStatusesRequest {
    /**
     * 
     * @type {TransactionHashes}
     * @memberof TransactionStatusRoutesApiGetTransactionStatuses
     */
    readonly transactionHashes: TransactionHashes
}

/**
 * TransactionStatusRoutesApi - object-oriented interface
 * @export
 * @class TransactionStatusRoutesApi
 * @extends {BaseAPI}
 */
export class TransactionStatusRoutesApi extends BaseAPI {
    /**
     * Returns the transaction status for a given hash.
     * @summary Get transaction status
     * @param {TransactionStatusRoutesApiGetTransactionStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionStatusRoutesApi
     */
    public getTransactionStatus(requestParameters: TransactionStatusRoutesApiGetTransactionStatusRequest, options?: AxiosRequestConfig) {
        return TransactionStatusRoutesApiFp(this.configuration).getTransactionStatus(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of transaction statuses for a given array of transaction hashes.
     * @summary Get transaction statuses
     * @param {TransactionStatusRoutesApiGetTransactionStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionStatusRoutesApi
     */
    public getTransactionStatuses(requestParameters: TransactionStatusRoutesApiGetTransactionStatusesRequest, options?: AxiosRequestConfig) {
        return TransactionStatusRoutesApiFp(this.configuration).getTransactionStatuses(requestParameters.transactionHashes, options).then((request) => request(this.axios, this.basePath));
    }
}


